; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Connecting using "Babashka" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 
; Starting Jack-in Terminal: pushd c:\Users\porko\Documents\GitHub\lisp-tutorial & bb --nrepl-server 53736 & popd
; Using host:port 127.0.0.1:53736 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
; Evaluating code from settings: 'calva.autoEvaluateCode.onConnect.clj'
nil
clj꞉user꞉>  ; Use `alt+enter` to evaluate
clj꞉user꞉> 
; Jack-in done.
clj꞉user꞉> 
nil
clj꞉user꞉> 
[#object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x5e14a991 "test\\foreclojure\\1"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2f99146b "test\\foreclojure\\10"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x476deb58 "test\\foreclojure\\11"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x58237852 "test\\foreclojure\\12"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x5b2bad4e "test\\foreclojure\\13"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x7558cd27 "test\\foreclojure\\14"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2a440cb4 "test\\foreclojure\\15"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x64657e03 "test\\foreclojure\\16"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x63855d35 "test\\foreclojure\\17"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x64ace9b0 "test\\foreclojure\\18"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0xdf2d89c "test\\foreclojure\\2"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x870e643 "test\\foreclojure\\3"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x6cf7476c "test\\foreclojure\\4"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x19390093 "test\\foreclojure\\5"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x7c2adda6 "test\\foreclojure\\6"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x53b7ea49 "test\\foreclojure\\7"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x376754db "test\\foreclojure\\8"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x7e92ad52 "test\\foreclojure\\9"]]
clj꞉user꞉> 
#'user/foreclojure
clj꞉user꞉> 
; java.lang.IllegalArgumentException: Cannot open <#object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x300f5d2e "test\\foreclojure\\1"]> as an InputStream. user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:1:1
clj꞉user꞉> 
#'user/foreclojure-problems
clj꞉user꞉> 
#'user/foreclojure
clj꞉user꞉> 
"(def truth (= false true))"
clj꞉user꞉> 
("(def truth (= false true))"
 "(def expr (= (- 10 (* 2 3)) n))"
 "(def s (. \"'goodbye'.toUpperCase\"))"
 "(def l (list 1 2 3))"
 "(def l '(3 4))"
 "(def v [])"
 "(def v [1 2])"
 "(def s #{:a :b :c})"
 "(def n 0)"
 "(def n 0)"
 "(def kv [:a 1])"
 "(def n 0)"
 "(def v [10 20 30 40])"
 "(def n 0)"
 "(def f \r\n  (fn [n]\r\n    ))"
 "(defn hello [name]\r\n  )"
 "(def l '(1 2 3))"
 "(def l '(3 4 5 6 7))")
clj꞉user꞉> 
nil
clj꞉user꞉> 
#'user/foreclojure-tests
clj꞉user꞉> 
nil
clj꞉user꞉> 
; java.lang.ClassCastException: java.lang.Long cannot be cast to clojure.lang.IFn user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:1:1
clj꞉user꞉> 
[#object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x52cf7cd2 "test\\foreclojure\\anagram.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x59ebb759 "test\\foreclojure\\anagram_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x43703771 "test\\foreclojure\\bal_num.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x101d426a "test\\foreclojure\\bal_num_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x44b1adc "test\\foreclojure\\bin.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0xfab16cf "test\\foreclojure\\bin_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2ba2e5a "test\\foreclojure\\black_box.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x686a93fb "test\\foreclojure\\black_box_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2530c35a "test\\foreclojure\\camel.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2c34d02a "test\\foreclojure\\camel_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x668ba218 "test\\foreclojure\\cards.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x40a67bc6 "test\\foreclojure\\cards_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3508a399 "test\\foreclojure\\cartesian.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x513c9efe "test\\foreclojure\\cartesian_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x60215ab7 "test\\foreclojure\\classes.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3ba348cc "test\\foreclojure\\classes_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x50cd1de7 "test\\foreclojure\\closure.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x621eb4c1 "test\\foreclojure\\closure_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3d66f9d "test\\foreclojure\\compress.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x73aaaf7f "test\\foreclojure\\compress_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x24a8e2a0 "test\\foreclojure\\conj_list.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x23dabbad "test\\foreclojure\\conj_list_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x455b9181 "test\\foreclojure\\conj_map.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3c75e1ea "test\\foreclojure\\conj_map_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x27a8ba82 "test\\foreclojure\\conj_set.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x20f9963b "test\\foreclojure\\conj_set_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0xeb7b9f4 "test\\foreclojure\\conj_vector.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x20e6523f "test\\foreclojure\\conj_vector_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x23e7d41a "test\\foreclojure\\conway.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x32647f1f "test\\foreclojure\\conway_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x21d3788d "test\\foreclojure\\count_elements.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x209809e1 "test\\foreclojure\\count_elements_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x4a60f9ba "test\\foreclojure\\cw.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3cc06bd "test\\foreclojure\\cw_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x77d04f83 "test\\foreclojure\\db.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x3623e930 "test\\foreclojure\\db_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x5faaa6d0 "test\\foreclojure\\deinterleave.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0xe36a28e "test\\foreclojure\\deinterleave_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x19a20d3e "test\\foreclojure\\digits.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x76bb588a "test\\foreclojure\\digits_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x5447f57f "test\\foreclojure\\double.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x2f752b44 "test\\foreclojure\\double_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x32c65da "test\\foreclojure\\drop_every_nth.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x5aeea666 "test\\foreclojure\\drop_every_nth_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x4e004cdc "test\\foreclojure\\dupseq.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x257c1192 "test\\foreclojure\\dupseq_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x411547d1 "test\\foreclojure\\eulerian.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x630088dc "test\\foreclojure\\eulerian_test.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x62d535a2 "test\\foreclojure\\f.clj"]
 #object[sun.nio.fs.WindowsPath$WindowsPathWithAttributes 0x68a41d9b "test\\foreclojure\\factorial.clj"]
 ...]
clj꞉user꞉> 
("test\\foreclojure\\anagram.clj"
 "test\\foreclojure\\anagram_test.clj"
 "test\\foreclojure\\bal_num.clj"
 "test\\foreclojure\\bal_num_test.clj"
 "test\\foreclojure\\bin.clj"
 "test\\foreclojure\\bin_test.clj"
 "test\\foreclojure\\black_box.clj"
 "test\\foreclojure\\black_box_test.clj"
 "test\\foreclojure\\camel.clj"
 "test\\foreclojure\\camel_test.clj"
 "test\\foreclojure\\cards.clj"
 "test\\foreclojure\\cards_test.clj"
 "test\\foreclojure\\cartesian.clj"
 "test\\foreclojure\\cartesian_test.clj"
 "test\\foreclojure\\classes.clj"
 "test\\foreclojure\\classes_test.clj"
 "test\\foreclojure\\closure.clj"
 "test\\foreclojure\\closure_test.clj"
 "test\\foreclojure\\compress.clj"
 "test\\foreclojure\\compress_test.clj"
 "test\\foreclojure\\conj_list.clj"
 "test\\foreclojure\\conj_list_test.clj"
 "test\\foreclojure\\conj_map.clj"
 "test\\foreclojure\\conj_map_test.clj"
 "test\\foreclojure\\conj_set.clj"
 "test\\foreclojure\\conj_set_test.clj"
 "test\\foreclojure\\conj_vector.clj"
 "test\\foreclojure\\conj_vector_test.clj"
 "test\\foreclojure\\conway.clj"
 "test\\foreclojure\\conway_test.clj"
 "test\\foreclojure\\count_elements.clj"
 "test\\foreclojure\\count_elements_test.clj"
 "test\\foreclojure\\cw.clj"
 "test\\foreclojure\\cw_test.clj"
 "test\\foreclojure\\db.clj"
 "test\\foreclojure\\db_test.clj"
 "test\\foreclojure\\deinterleave.clj"
 "test\\foreclojure\\deinterleave_test.clj"
 "test\\foreclojure\\digits.clj"
 "test\\foreclojure\\digits_test.clj"
 "test\\foreclojure\\double.clj"
 "test\\foreclojure\\double_test.clj"
 "test\\foreclojure\\drop_every_nth.clj"
 "test\\foreclojure\\drop_every_nth_test.clj"
 "test\\foreclojure\\dupseq.clj"
 "test\\foreclojure\\dupseq_test.clj"
 "test\\foreclojure\\eulerian.clj"
 "test\\foreclojure\\eulerian_test.clj"
 "test\\foreclojure\\f.clj"
 "test\\foreclojure\\factorial.clj"
 ...)
clj꞉user꞉> 
#'user/foreclojure-exercises
clj꞉user꞉> 
"e\\anagram"
clj꞉user꞉> 
#'user/foreclojure-exercises
clj꞉user꞉> 
"anagram"
clj꞉user꞉> 
#'user/foreclojure
clj꞉user꞉> 
nil
clj꞉user꞉> 
("test\\foreclojure\\anagram.clj"
 "test\\foreclojure\\anagram_test.clj"
 "test\\foreclojure\\bal_num.clj"
 "test\\foreclojure\\bal_num_test.clj"
 "test\\foreclojure\\bin.clj"
 "test\\foreclojure\\bin_test.clj"
 "test\\foreclojure\\black_box.clj"
 "test\\foreclojure\\black_box_test.clj"
 "test\\foreclojure\\camel.clj"
 "test\\foreclojure\\camel_test.clj"
 "test\\foreclojure\\cards.clj"
 "test\\foreclojure\\cards_test.clj"
 "test\\foreclojure\\cartesian.clj"
 "test\\foreclojure\\cartesian_test.clj"
 "test\\foreclojure\\classes.clj"
 "test\\foreclojure\\classes_test.clj"
 "test\\foreclojure\\closure.clj"
 "test\\foreclojure\\closure_test.clj"
 "test\\foreclojure\\compress.clj"
 "test\\foreclojure\\compress_test.clj"
 "test\\foreclojure\\conj_list.clj"
 "test\\foreclojure\\conj_list_test.clj"
 "test\\foreclojure\\conj_map.clj"
 "test\\foreclojure\\conj_map_test.clj"
 "test\\foreclojure\\conj_set.clj"
 "test\\foreclojure\\conj_set_test.clj"
 "test\\foreclojure\\conj_vector.clj"
 "test\\foreclojure\\conj_vector_test.clj"
 "test\\foreclojure\\conway.clj"
 "test\\foreclojure\\conway_test.clj"
 "test\\foreclojure\\count_elements.clj"
 "test\\foreclojure\\count_elements_test.clj"
 "test\\foreclojure\\cw.clj"
 "test\\foreclojure\\cw_test.clj"
 "test\\foreclojure\\db.clj"
 "test\\foreclojure\\db_test.clj"
 "test\\foreclojure\\deinterleave.clj"
 "test\\foreclojure\\deinterleave_test.clj"
 "test\\foreclojure\\digits.clj"
 "test\\foreclojure\\digits_test.clj"
 "test\\foreclojure\\double.clj"
 "test\\foreclojure\\double_test.clj"
 "test\\foreclojure\\drop_every_nth.clj"
 "test\\foreclojure\\drop_every_nth_test.clj"
 "test\\foreclojure\\dupseq.clj"
 "test\\foreclojure\\dupseq_test.clj"
 "test\\foreclojure\\eulerian.clj"
 "test\\foreclojure\\eulerian_test.clj"
 "test\\foreclojure\\f.clj"
 "test\\foreclojure\\factorial.clj"
 ...)
clj꞉user꞉> 
#'user/foreclojure-exercises
clj꞉user꞉> 
("anagram"
 "anagram_test"
 "bal_num"
 "bal_num_test"
 "bin"
 "bin_test"
 "black_box"
 "black_box_test"
 "camel"
 "camel_test"
 "cards"
 "cards_test"
 "cartesian"
 "cartesian_test"
 "classes"
 "classes_test"
 "closure"
 "closure_test"
 "compress"
 "compress_test"
 "conj_list"
 "conj_list_test"
 "conj_map"
 "conj_map_test"
 "conj_set"
 "conj_set_test"
 "conj_vector"
 "conj_vector_test"
 "conway"
 "conway_test"
 "count_elements"
 "count_elements_test"
 "cw"
 "cw_test"
 "db"
 "db_test"
 "deinterleave"
 "deinterleave_test"
 "digits"
 "digits_test"
 "double"
 "double_test"
 "drop_every_nth"
 "drop_every_nth_test"
 "dupseq"
 "dupseq_test"
 "eulerian"
 "eulerian_test"
 "f"
 "factorial"
 ...)
clj꞉user꞉> 
("anagram"
 "anagram_test"
 "bal_num"
 "bal_num_test"
 "bin"
 "bin_test"
 "black_box"
 "black_box_test"
 "camel"
 "camel_test"
 "cards"
 "cards_test"
 "cartesian"
 "cartesian_test"
 "classes"
 "classes_test"
 "closure"
 "closure_test"
 "compress"
 "compress_test"
 "conj_list"
 "conj_list_test"
 "conj_map"
 "conj_map_test"
 "conj_set"
 "conj_set_test"
 "conj_vector"
 "conj_vector_test"
 "conway"
 "conway_test"
 "count_elements"
 "count_elements_test"
 "cw"
 "cw_test"
 "db"
 "db_test"
 "deinterleave"
 "deinterleave_test"
 "digits"
 "digits_test"
 "double"
 "double_test"
 "drop_every_nth"
 "drop_every_nth_test"
 "dupseq"
 "dupseq_test"
 "eulerian"
 "eulerian_test"
 "f"
 "factorial"
 ...)
clj꞉user꞉> 
#'user/foreclojure-exercises
clj꞉user꞉> 
{false
 ["anagram"
  "anagram_test"
  "bal_num"
  "bal_num_test"
  "bin"
  "bin_test"
  "black_box"
  "black_box_test"
  "camel"
  "camel_test"
  "cards"
  "cards_test"
  "cartesian"
  "cartesian_test"
  "classes"
  "classes_test"
  "closure"
  "closure_test"
  "compress"
  "compress_test"
  "conj_list"
  "conj_list_test"
  "conj_map"
  "conj_map_test"
  "conj_set"
  "conj_set_test"
  "conj_vector"
  "conj_vector_test"
  "conway"
  "conway_test"
  "count_elements"
  "count_elements_test"
  "cw"
  "cw_test"
  "db"
  "db_test"
  "deinterleave"
  "deinterleave_test"
  "digits"
  "digits_test"
  "double"
  "double_test"
  "drop_every_nth"
  "drop_every_nth_test"
  "dupseq"
  "dupseq_test"
  "eulerian"
  "eulerian_test"
  "f"
  "factorial"
  ...]}
clj꞉user꞉> 
{false
 ["anagram"
  "anagram_test"
  "bal_num"
  "bal_num_test"
  "bin"
  "bin_test"
  "black_box"
  "black_box_test"
  "camel"
  "camel_test"
  "cards"
  "cards_test"
  "cartesian"
  "cartesian_test"
  "classes"
  "classes_test"
  "closure"
  "closure_test"
  "compress"
  "compress_test"
  "conj_list"
  "conj_list_test"
  "conj_map"
  "conj_map_test"
  "conj_set"
  "conj_set_test"
  "conj_vector"
  "conj_vector_test"
  "conway"
  "conway_test"
  "count_elements"
  "count_elements_test"
  "cw"
  "cw_test"
  "db"
  "db_test"
  "deinterleave"
  "deinterleave_test"
  "digits"
  "digits_test"
  "double"
  "double_test"
  "drop_every_nth"
  "drop_every_nth_test"
  "dupseq"
  "dupseq_test"
  "eulerian"
  "eulerian_test"
  "f"
  "factorial"
  ...]}
clj꞉user꞉> 
{false
 ["anagram"
  "bal_num"
  "bin"
  "black_box"
  "camel"
  "cards"
  "cartesian"
  "classes"
  "closure"
  "compress"
  "conj_list"
  "conj_map"
  "conj_set"
  "conj_vector"
  "conway"
  "count_elements"
  "cw"
  "db"
  "deinterleave"
  "digits"
  "double"
  "drop_every_nth"
  "dupseq"
  "eulerian"
  "f"
  "factorial"
  "fib"
  "filter"
  "find_path"
  "flipper"
  "functions"
  "gcd"
  "getcaps"
  "get_highest"
  "graph"
  "gtw"
  "hack"
  "half_truth"
  "happy"
  "hello"
  "inject"
  "intervals"
  "k"
  "key_val"
  "last"
  "lazy"
  "lcm"
  "lev"
  "lists"
  "longest_subseq"
  ...],
 true
 ["anagram_test"
  "bal_num_test"
  "bin_test"
  "black_box_test"
  "camel_test"
  "cards_test"
  "cartesian_test"
  "classes_test"
  "closure_test"
  "compress_test"
  "conj_list_test"
  "conj_map_test"
  "conj_set_test"
  "conj_vector_test"
  "conway_test"
  "count_elements_test"
  "cw_test"
  "db_test"
  "deinterleave_test"
  "digits_test"
  "double_test"
  "drop_every_nth_test"
  "dupseq_test"
  "eulerian_test"
  "factorial_test"
  "fib_test"
  "filter_test"
  "find_path_test"
  "flipper_test"
  "functions_test"
  "f_test"
  "gcd_test"
  "getcaps_test"
  "get_highest_test"
  "graph_test"
  "gtw_test"
  "hack_test"
  "half_truth_test"
  "happy_test"
  "hello_test"
  "inject_test"
  "intervals_test"
  "key_val_test"
  "k_test"
  "last_test"
  "lazy_test"
  "lcm_test"
  "lev_test"
  "lists_test"
  "lj_test"
  ...]}
clj꞉user꞉> 
#'user/ex-test
clj꞉user꞉> 
#'user/exercises
clj꞉user꞉> 
[false
 ["anagram"
  "bal_num"
  "bin"
  "black_box"
  "camel"
  "cards"
  "cartesian"
  "classes"
  "closure"
  "compress"
  "conj_list"
  "conj_map"
  "conj_set"
  "conj_vector"
  "conway"
  "count_elements"
  "cw"
  "db"
  "deinterleave"
  "digits"
  "double"
  "drop_every_nth"
  "dupseq"
  "eulerian"
  "f"
  "factorial"
  "fib"
  "filter"
  "find_path"
  "flipper"
  "functions"
  "gcd"
  "getcaps"
  "get_highest"
  "graph"
  "gtw"
  "hack"
  "half_truth"
  "happy"
  "hello"
  "inject"
  "intervals"
  "k"
  "key_val"
  "last"
  "lazy"
  "lcm"
  "lev"
  "lists"
  "longest_subseq"
  ...]]
clj꞉user꞉> 
[true
 ["anagram_test"
  "bal_num_test"
  "bin_test"
  "black_box_test"
  "camel_test"
  "cards_test"
  "cartesian_test"
  "classes_test"
  "closure_test"
  "compress_test"
  "conj_list_test"
  "conj_map_test"
  "conj_set_test"
  "conj_vector_test"
  "conway_test"
  "count_elements_test"
  "cw_test"
  "db_test"
  "deinterleave_test"
  "digits_test"
  "double_test"
  "drop_every_nth_test"
  "dupseq_test"
  "eulerian_test"
  "factorial_test"
  "fib_test"
  "filter_test"
  "find_path_test"
  "flipper_test"
  "functions_test"
  "f_test"
  "gcd_test"
  "getcaps_test"
  "get_highest_test"
  "graph_test"
  "gtw_test"
  "hack_test"
  "half_truth_test"
  "happy_test"
  "hello_test"
  "inject_test"
  "intervals_test"
  "key_val_test"
  "k_test"
  "last_test"
  "lazy_test"
  "lcm_test"
  "lev_test"
  "lists_test"
  "lj_test"
  ...]]
clj꞉user꞉> 
#'user/tests
clj꞉user꞉> 
#'user/foreclojure-exercises
clj꞉user꞉> 
#'user/ex-test
clj꞉user꞉> 
#'user/exercises
clj꞉user꞉> 
#'user/tests
clj꞉user꞉> 
; java.lang.IllegalArgumentException: No implementation of method: :as-file of protocol: #'clojure.java.io/Coercions found for class: java.lang.Boolean user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:3:13
clj꞉user꞉> 
false
clj꞉user꞉> 
#'user/exercises
clj꞉user꞉> 
[false
 ["anagram"
  "bal_num"
  "bin"
  "black_box"
  "camel"
  "cards"
  "cartesian"
  "classes"
  "closure"
  "compress"
  "conj_list"
  "conj_map"
  "conj_set"
  "conj_vector"
  "conway"
  "count_elements"
  "cw"
  "db"
  "deinterleave"
  "digits"
  "double"
  "drop_every_nth"
  "dupseq"
  "eulerian"
  "f"
  "factorial"
  "fib"
  "filter"
  "find_path"
  "flipper"
  "functions"
  "gcd"
  "getcaps"
  "get_highest"
  "graph"
  "gtw"
  "hack"
  "half_truth"
  "happy"
  "hello"
  "inject"
  "intervals"
  "k"
  "key_val"
  "last"
  "lazy"
  "lcm"
  "lev"
  "lists"
  "longest_subseq"
  ...]]
clj꞉user꞉> 
#'user/exercises
clj꞉user꞉> 
(["anagram"
  "bal_num"
  "bin"
  "black_box"
  "camel"
  "cards"
  "cartesian"
  "classes"
  "closure"
  "compress"
  "conj_list"
  "conj_map"
  "conj_set"
  "conj_vector"
  "conway"
  "count_elements"
  "cw"
  "db"
  "deinterleave"
  "digits"
  "double"
  "drop_every_nth"
  "dupseq"
  "eulerian"
  "f"
  "factorial"
  "fib"
  "filter"
  "find_path"
  "flipper"
  "functions"
  "gcd"
  "getcaps"
  "get_highest"
  "graph"
  "gtw"
  "hack"
  "half_truth"
  "happy"
  "hello"
  "inject"
  "intervals"
  "k"
  "key_val"
  "last"
  "lazy"
  "lcm"
  "lev"
  "lists"
  "longest_subseq"
  ...])
clj꞉user꞉> 
("anagram"
 "bal_num"
 "bin"
 "black_box"
 "camel"
 "cards"
 "cartesian"
 "classes"
 "closure"
 "compress"
 "conj_list"
 "conj_map"
 "conj_set"
 "conj_vector"
 "conway"
 "count_elements"
 "cw"
 "db"
 "deinterleave"
 "digits"
 "double"
 "drop_every_nth"
 "dupseq"
 "eulerian"
 "f"
 "factorial"
 "fib"
 "filter"
 "find_path"
 "flipper"
 "functions"
 "gcd"
 "getcaps"
 "get_highest"
 "graph"
 "gtw"
 "hack"
 "half_truth"
 "happy"
 "hello"
 "inject"
 "intervals"
 "k"
 "key_val"
 "last"
 "lazy"
 "lcm"
 "lev"
 "lists"
 "longest_subseq"
 ...)
clj꞉user꞉> 
[true
 ["anagram_test"
  "bal_num_test"
  "bin_test"
  "black_box_test"
  "camel_test"
  "cards_test"
  "cartesian_test"
  "classes_test"
  "closure_test"
  "compress_test"
  "conj_list_test"
  "conj_map_test"
  "conj_set_test"
  "conj_vector_test"
  "conway_test"
  "count_elements_test"
  "cw_test"
  "db_test"
  "deinterleave_test"
  "digits_test"
  "double_test"
  "drop_every_nth_test"
  "dupseq_test"
  "eulerian_test"
  "factorial_test"
  "fib_test"
  "filter_test"
  "find_path_test"
  "flipper_test"
  "functions_test"
  "f_test"
  "gcd_test"
  "getcaps_test"
  "get_highest_test"
  "graph_test"
  "gtw_test"
  "hack_test"
  "half_truth_test"
  "happy_test"
  "hello_test"
  "inject_test"
  "intervals_test"
  "key_val_test"
  "k_test"
  "last_test"
  "lazy_test"
  "lcm_test"
  "lev_test"
  "lists_test"
  "lj_test"
  ...]]
clj꞉user꞉> 
("anagram_test"
 "bal_num_test"
 "bin_test"
 "black_box_test"
 "camel_test"
 "cards_test"
 "cartesian_test"
 "classes_test"
 "closure_test"
 "compress_test"
 "conj_list_test"
 "conj_map_test"
 "conj_set_test"
 "conj_vector_test"
 "conway_test"
 "count_elements_test"
 "cw_test"
 "db_test"
 "deinterleave_test"
 "digits_test"
 "double_test"
 "drop_every_nth_test"
 "dupseq_test"
 "eulerian_test"
 "factorial_test"
 "fib_test"
 "filter_test"
 "find_path_test"
 "flipper_test"
 "functions_test"
 "f_test"
 "gcd_test"
 "getcaps_test"
 "get_highest_test"
 "graph_test"
 "gtw_test"
 "hack_test"
 "half_truth_test"
 "happy_test"
 "hello_test"
 "inject_test"
 "intervals_test"
 "key_val_test"
 "k_test"
 "last_test"
 "lazy_test"
 "lcm_test"
 "lev_test"
 "lists_test"
 "lj_test"
 ...)
clj꞉user꞉> 
#'user/tests
clj꞉user꞉> 
#'user/exercises
clj꞉user꞉> 
#'user/src-all
clj꞉user꞉> 
; java.io.FileNotFoundException: test\anagram\anagram.clj (The system cannot find the path specified) user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:4:7
clj꞉user꞉> 
"anagram"
clj꞉user꞉> 
; java.io.FileNotFoundException: test\anagram\anagram.clj (The system cannot find the path specified) user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:4:3
clj꞉user꞉> 
#object[java.io.File 0x32a4e289 "test\\anagram\\anagram.clj"]
clj꞉user꞉> 
#object[java.io.File 0x574f49dc "test\\anagram.clj"]
clj꞉user꞉> 
#'user/src-all
clj꞉user꞉> 
; java.io.FileNotFoundException: test\anagram.clj (The system cannot find the file specified) user c:\Users\porko\Documents\GitHub\lisp-tutorial\scratch.clj:4:7
clj꞉user꞉> 
#'user/src-all
clj꞉user꞉> 
("(defn anagram [c]\r\n  (set (for [[_ g] (group-by frequencies c)\r\n             :when (next g)]\r\n         (set g))))"
 "(defn bal-num [n]\r\n  (let [s (map #(- (int %) 48) (str n))\r\n        l (/ (count s) 2)\r\n        [a b] (map #(apply + (take l %)) [s (into () s)])]\r\n    (= a b)))"
 "(defn bin [n]\r\n  (apply + (map #(if (= \\1 %1)\r\n                   (apply * (repeat %2 2)) 0)\r\n                (reverse n) (range))))"
 " (defn black-box [c]\r\n  ((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))"
 "(defn camel [s]\r\n  (let [words (re-seq #\"[a-zA-Z]+\" s)\r\n        words (cons (first words)\r\n                    (map clojure.string/capitalize\r\n                         (rest words)))]\r\n    (apply str words)))"
 "(defn cards [c]\r\n  {:suit ({\\H :heart \\C :club \\S :spade \\D :diamond} (first c))\r\n   :rank ((zipmap \"23456789TJQKA\" (range)) (second c))})"
 "(defn cartesian [x y]\r\n  (set (for [a x b y] [a b])))"
 "(defn classes [f c]\r\n  (set (map set (vals (group-by f c)))))"
 "(defn closure [n] #(apply * (repeat n %)))"
 "(defn compress [s]\r\n  (map first\r\n       (partition-by identity s)))"
 "(def l '(3 4))"
 "(def kv [:a 1])"
 "(def n 0)"
 "(def v [1 2])"
 "(defn conway [board]\r\n  (let [r (range (count board))\r\n        v [-1 0 1]\r\n        a \\#]\r\n    (for [y r]\r\n      (apply str (for [x r c [(count\r\n                               (for [j v\r\n                                     k v\r\n                                     :when (= a (get-in board [(+ y j) (+ x k)]))]\r\n                                 1))]]\r\n                   (if (or (= c 3) (and (= c 4) (= a (get-in board [y x]))))\r\n                     a\r\n                     \\ ))))))"
 "(defn count-elements [s]\r\n  (loop [x s acc 0]\r\n    (if (empty? x)\r\n      acc\r\n      (recur (rest x) (inc acc)))))"
 "(defn cw [word board]\r\n  (let [across (map #(clojure.string/escape % {\\space \"\", \\_ \\.}) board)\r\n        down (apply map str across)]   ;; transpose the board so down becomes across\r\n    (string? (->> (concat across down)\r\n                  (mapcat #(clojure.string/split % #\"#\"))\r\n                  (some #(re-matches (re-pattern %) word))))))"
 "(defn digits [n b]\r\n  (if (< n b)\r\n    [n]\r\n    (conj (digits (quot n b) b) (rem n b))))"
 "(defn deinterleave [coll n]\r\n  (apply map list (partition n coll)))"
 "(defn digits [x y]\r\n  (map #(- (int %) (int \\0)) (str (* x y))))"
 "(def f \r\n  (fn [n]\r\n    ))"
 "(defn drop-every-nth [s n]\r\n  (apply concat (partition-all (dec n) n s)))"
 "(defn dupseq [s]\r\n  (interleave s s))"
 "(defn eulerian [e]\r\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\r\n    (not (next (reduce\r\n                (fn [g e]\r\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\r\n                    (conj (disj g a b) (into a b))))\r\n                #{}\r\n                e)))\r\n    false))"
 "(defn f [grid]\r\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\r\n        parts (for [y (range (count grid))\r\n                    x (range (count (nth grid y)))\r\n                    :let [e (get-in grid [y x])]]\r\n                {({\\C :cat \\M :mouse \\# :wall \\space :space} e) [x y]})\r\n        game (apply merge-with conj {:wall [] :space []} parts)\r\n        spaces (conj (set (:space game)) (:mouse game))]\r\n    (loop [open [(:cat game)] visited #{}]\r\n      (cond\r\n        (empty? open) false\r\n        (= (first open) (:mouse game)) true\r\n        :else (let [visited (conj visited (first open))\r\n                    neigh (filter spaces (neighbors (first open)))\r\n                    neigh (remove visited neigh)\r\n                    open (concat (rest open) (remove visited neigh))]\r\n                (recur open visited))))))"
 "(defn factorial [n]\r\n  (reduce * (range 1 (inc n))))"
 "(defn fib [a b]\r\n  (lazy-seq (cons a (fib b (+ a b)))))"
 "(def l '(3 4 5 6 7))"
 "(defn find-path [s e]\r\n  (loop [opts [s] depth 1]\r\n    (if (some #{e} opts)\r\n      depth\r\n      (letfn [(solutions [n]\r\n                (concat\r\n                 [(* n 2) (+ n 2)]\r\n                 (if (even? n) [(/ n 2)] [])))]\r\n        (recur (mapcat solutions opts) (inc depth))))))"
 "(defn flipper [f]\r\n  #(f %2 %))"
 "(def n 0)"
 "(defn gcd [a b]\r\n  (if (= 0 b) a (recur b (mod a b))))"
 "(defn getcaps [s]\r\n  (apply str (re-seq #\"[A-Z]\" s)))"
 "(defn get-highest [& all]\r\n  (last (sort all)))"
 "(defn graph [g]\r\n  ((fn f [e]\r\n     (#(if (= e %) (= % g) (f %))\r\n      (reduce (fn [a b] (into a (filter #(some (set b) %) g)))\r\n              #{}\r\n              e)))\r\n   #{(first g)}))"
 "(defn gtw [n p [x & r]]\r\n  (lazy-seq\r\n   (when x\r\n     (let [remaining (if (p x) (dec n) n)]\r\n       (when (pos? remaining)\r\n         (cons x (gtw remaining p r)))))))"
 "(defn hack [n s]\r\n  [(take n s) (drop n s)])"
 "(defn half-truth [& vs]\r\n  (true? (and (some not vs)\r\n              (some identity vs))))"
 "(defn happy [n]\r\n  (loop [n n\r\n         s #{}]\r\n    (let [x (apply + (map #(let [i (- (int %) (int \\0))] (* i i)) (str n)))]\r\n      (cond (= x 1) true\r\n            (s x) false\r\n            :else (recur x (conj s x))))))"
 "(defn hello [name]\r\n  )"
 "(defn inject [x coll]\r\n  (rest (interleave (repeat x) coll)))"
 "(defn intervals [coll]\r\n  (reverse (reduce (fn [[[a b] & r :as is] n]\r\n                     (if (and a (= (inc b) n))\r\n                       (cons [a n] r)\r\n                       (cons [n n] is)))\r\n                   ()\r\n                   (distinct (sort coll)))))"
 "(defn k [i s]\r\n  (set\r\n   (if (= i 0)\r\n     [#{}]\r\n     (mapcat #(for [p (k (- i 1) %2)] (conj p %))\r\n             s (next (iterate next s))))))"
 "(defn key-val [c]\r\n  (loop [[f & r] c, kvm {}]\r\n    (if (nil? f)\r\n      kvm\r\n      (let [[vs l] (split-with (complement keyword?) r)]\r\n        (recur l (assoc kvm f vs))))))"
 "(defn my-last [s]\r\n  (if (next s)\r\n    (recur (next s))\r\n    (first s)))"
 "(defn lazy [& s]\r\n  (loop [v (vec s)]\r\n    (let [first-vals (map first v)\r\n          smallest (apply min first-vals)]\r\n      (if (= smallest (apply max first-vals))\r\n        smallest\r\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\r\n          (recur (update-in v [i] next)))))))"
 "(defn lcm [& args]\r\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (/ (reduce * args) (reduce gcd args))))"
 "(defn lev [s t]\r\n  (let [f (fn [f s t]\r\n            (cond\r\n              (empty? s) (count t)\r\n              (empty? t) (count s)\r\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\r\n                      (min (inc (f f (rest s) t))\r\n                           (inc (f f s (rest t)))\r\n                           (+ cost (f f (rest s) (rest t)))))))\r\n        g (memoize f)]\r\n    (g g s t)))"
 "(def l (list 1 2 3))"
 "(defn longest-subseq [s]\r\n  (or (first (for [l (reverse (range 2 (count s)))\r\n                   f (filter #(apply < %) (partition l 1 s))]\r\n               f)) []))"
 ...)
clj꞉user꞉> 
("(deftest test-77\r\n  (is (= (anagram [\"meat\" \"mat\" \"team\" \"mate\" \"eat\"]) #{#{\"meat\" \"team\" \"mate\"}}))\r\n  (is (= (anagram [\"veer\" \"lake\" \"item\" \"kale\" \"mite\" \"ever\"]) #{#{\"veer\" \"ever\"} #{\"lake\" \"kale\"} #{\"mite\" \"item\"}})))"
 "(deftest test-115\r\n  (is (= true (bal-num 11)))\r\n  (is (= true (bal-num 121)))\r\n  (is (= false (bal-num 123)))\r\n  (is (= true (bal-num 0)))\r\n  (is (= false (bal-num 88099)))\r\n  (is (= true (bal-num 89098)))\r\n  (is (= true (bal-num 89089)))\r\n  (is (= (take 20 (filter bal-num (range)))\r\n         [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101])))"
 "(deftest test-122\r\n  (is (= 0     (bin \"0\")))\r\n  (is (= 7     (bin \"111\")))\r\n  (is (= 8     (bin \"1000\")))\r\n  (is (= 9     (bin \"1001\")))\r\n  (is (= 255   (bin \"11111111\")))\r\n  (is (= 1365  (bin \"10101010101\")))\r\n  (is (= 65535 (bin \"1111111111111111\"))))"
 "(deftest test-65\r\n  (is (= :map (black-box {:a 1, :b 2})))\r\n  (is (= :list (black-box (range (rand-int 20)))))\r\n  (is (= :set (black-box #{10 (rand-int 5)})))\r\n  (is (= :vector (black-box [1 2 3 4 5 6])))\r\n  (is (= [:map :set :vector :list] (map black-box [{} #{} [] ()]))))"
 "(deftest test-102\r\n  (is (= (camel \"something\") \"something\"))\r\n  (is (= (camel \"multi-word-key\") \"multiWordKey\"))\r\n  (is (= (camel \"leaveMeAlone\") \"leaveMeAlone\")))"
 "(deftest test-128\r\n  (is (= {:suit :diamond :rank 10} (cards \"DQ\")))\r\n  (is (= {:suit :heart :rank 3} (cards \"H5\")))\r\n  (is (= {:suit :club :rank 12} (cards \"CA\")))\r\n  (is (= (range 13) (map (comp :rank cards str)\r\n                         '[S2 S3 S4 S5 S6 S7\r\n                           S8 S9 ST SJ SQ SK SA]))))"
 "(deftest test-90\r\n  (is (= (cartesian #{\"ace\" \"king\" \"queen\"} #{\"♠\" \"♥\" \"♦\" \"♣\"})\r\n         #{[\"ace\"   \"♠\"] [\"ace\"   \"♥\"] [\"ace\"   \"♦\"] [\"ace\"   \"♣\"]\r\n           [\"king\"  \"♠\"] [\"king\"  \"♥\"] [\"king\"  \"♦\"] [\"king\"  \"♣\"]\r\n           [\"queen\" \"♠\"] [\"queen\" \"♥\"] [\"queen\" \"♦\"] [\"queen\" \"♣\"]}))\r\n  (is (= (cartesian #{1 2 3} #{4 5})\r\n         #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]}))\r\n  (is (= 300 (count (cartesian (into #{} (range 10))\r\n                               (into #{} (range 30)))))))"
 "(deftest test-98\r\n  (is (= (classes #(* % %) #{-2 -1 0 1 2})\r\n         #{#{0} #{1 -1} #{2 -2}}))\r\n  (is (= (classes #(rem % 3) #{0 1 2 3 4 5})\r\n         #{#{0 3} #{1 4} #{2 5}}))\r\n  (is (= (classes identity #{0 1 2 3 4})\r\n         #{#{0} #{1} #{2} #{3} #{4}}))\r\n  (is (= (classes (constantly true) #{0 1 2 3 4})\r\n         #{#{0 1 2 3 4}})))"
 "(deftest test-107\r\n  (is (= 256 ((closure 2) 16), ((closure 8) 2)))\r\n  (is (= [1 8 27 64] (map (closure 3) [1 2 3 4])))\r\n  (is (= [1 2 4 8 16] (map #((closure %) 2) [0 1 2 3 4]))))"
 "(deftest test-30\r\n  (is (= (apply str (compress \"Leeeeeerrroyyy\")) \"Leroy\"))\r\n  (is (= (compress [1 1 2 3 3 2 2 3]) '(1 2 3 2 3)))\r\n  (is (= (compress [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))))"
 "(deftest conj-list-test\r\n  (is (= l (conj '(2 3 4) 1)))\r\n  (is (= l (conj '(3 4) 2 1))))"
 "(deftest conj-map-test\r\n  (is (= {:a 1, :b 2, :c 3} (conj {:a 1} kv [:c 3]))))"
 "(deftest conj-set-test\r\n  (is (= #{1 2 3 4} (conj #{1 4 3} n))))"
 "(deftest conj-vectors-test\r\n  (is (= v (conj [1 2 3] 4)))\r\n  (is (= v (conj [1 2] 3 4))))"
 "(deftest test-94\r\n  (is (= (conway [\"      \"\r\n                  \" ##   \"\r\n                  \" ##   \"\r\n                  \"   ## \"\r\n                  \"   ## \"\r\n                  \"      \"])\r\n         [\"      \"\r\n          \" ##   \"\r\n          \" #    \"\r\n          \"    # \"\r\n          \"   ## \"\r\n          \"      \"]))\r\n  (is (= (conway [\"     \"\r\n                  \"     \"\r\n                  \" ### \"\r\n                  \"     \"\r\n                  \"     \"]))\r\n      [\"     \"\r\n       \"  #  \"\r\n       \"  #  \"\r\n       \"  #  \"\r\n       \"     \"])\r\n  (is (= (conway [\"      \"\r\n                  \"      \"\r\n                  \"  ### \"\r\n                  \" ###  \"\r\n                  \"      \"\r\n                  \"      \"])\r\n         [\"      \"\r\n          \"   #  \"\r\n          \" #  # \"\r\n          \" #  # \"\r\n          \"  #   \"\r\n          \"      \"])))"
 "(deftest test-22\r\n  (is (= (count-elements '(1 2 3 3 1)) 5))\r\n  (is (= (count-elements \"Hello World\") 11))\r\n  (is (= (count-elements [[1 2] [3 4] [5 6]]) 3))\r\n  (is (= (count-elements '(13)) 1))\r\n  (is (= (count-elements '(:a :b :c)) 3)))"
 "(deftest test-111\r\n  (is (= true  (cw \"the\" [\"_ # _ _ e\"])))\r\n  (is (= false (cw \"the\" [\"c _ _ _\"\r\n                          \"d _ # e\"\r\n                          \"r y _ _\"])))\r\n  (is (= true  (cw \"joy\" [\"c _ _ _\"\r\n                          \"d _ # e\"\r\n                          \"r y _ _\"])))\r\n  (is (= false (cw \"joy\" [\"c o n j\"\r\n                          \"_ _ y _\"\r\n                          \"r _ _ #\"])))\r\n  (is (= true  (cw \"clojure\" [\"_ _ _ # j o y\"\r\n                              \"_ _ o _ _ _ _\"\r\n                              \"_ _ f _ # _ _\"]))))"
 "(deftest test-137\r\n  (is (= [1 2 3 4 5 0 1] (digits 1234501 10)))\r\n  (is (= [0] (digits 0 11)))\r\n  (is (= [1 0 0 1] (digits 9 2)))\r\n  (is (= [1 0] (let [n (rand-int 100000)] (digits n n))))\r\n  (is (= [16 18 5 24 15 1] (digits Integer/MAX_VALUE 42))))"
 "(deftest test-43\r\n  (is (= (deinterleave [1 2 3 4 5 6] 2) '((1 3 5) (2 4 6))))\r\n  (is (= (deinterleave (range 9) 3) '((0 3 6) (1 4 7) (2 5 8))))\r\n  (is (= (deinterleave (range 10) 5) '((0 5) (1 6) (2 7) (3 8) (4 9)))))"
 "(deftest test-99\r\n  (is (= (digits 1 1) [1]))\r\n  (is (= (digits 99 9) [8 9 1]))\r\n  (is (= (digits 999 99) [9 8 9 0 1])))"
 "(deftest double-test\r\n  (is (= (f 2) 4))\r\n  (is (= (f 3) 6))\r\n  (is (= (f 11) 22))\r\n  (is (= (f 7) 14)))"
 "(deftest test-41\r\n  (is (= (drop-every-nth [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8]))\r\n  (is (= (drop-every-nth [:a :b :c :d :e :f] 2) [:a :c :e]))\r\n  (is (= (drop-every-nth [1 2 3 4 5 6] 4) [1 2 3 5 6])))"
 "(deftest test-32\r\n  (is (= (dupseq [1 2 3]) '(1 1 2 2 3 3)))\r\n  (is (= (dupseq [:a :a :b :b]) '(:a :a :a :a :b :b :b :b)))\r\n  (is (= (dupseq [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4])))\r\n  (is (= (dupseq [44 33]) [44 44 33 33])))"
 "(deftest test-89\r\n  (is (= true (eulerian [[:a :b]])))\r\n  (is (= false (eulerian [[:a :a] [:b :b]])))\r\n  (is (= false (eulerian [[:a :b] [:a :b] [:a :c] [:c :a]\r\n                          [:a :d] [:b :d] [:c :d]])))\r\n  (is (= true (eulerian [[1 2] [2 3] [3 4] [4 1]])))\r\n  (is (= true (eulerian [[:a :b] [:a :c] [:c :b] [:a :e]\r\n                         [:b :e] [:a :d] [:b :d] [:c :e]\r\n                         [:d :e] [:c :f] [:d :f]])))\r\n  (is (= false (eulerian [[1 2] [2 3] [2 4] [2 5]]))))"
 "(deftest test-42\r\n  (is (= (factorial 1) 1))\r\n  (is (= (factorial 3) 6))\r\n  (is (= (factorial 5) 120))\r\n  (is (= (factorial 8) 40320)))"
 "(deftest test-26\r\n  (is (= (take 1 (fib 0 1)) '(0)))\r\n  (is (= (take 2 (fib 0 1)) '(0 1)))\r\n  (is (= (take 3 (fib 0 1)) '(0 1 1)))\r\n  (is (= (take 4 (fib 0 1)) '(0 1 1 2)))\r\n  (is (= (take 5 (fib 0 1)) '(0 1 1 2 3)))\r\n  (is (= (take 6 (fib 0 1)) '(0 1 1 2 3 5)))\r\n  (is (= (take 7 (fib 0 1)) '(0 1 1 2 3 5 8)))\r\n  (is (= (take 8 (fib 0 1)) '(0 1 1 2 3 5 8 13)))\r\n  (is (= (take 9 (fib 0 1)) '(0 1 1 2 3 5 8 13 21)))\r\n  (is (= (take 10 (fib 0 1)) '(0 1 1 2 3 5 8 13 21 34))))"
 "(deftest filter-test\r\n  (is (= l (filter #(> % 5) '(3 4 5 6 7)))))"
 "(deftest test-106\r\n  (is (= 1 (find-path 1 1)))\r\n  (is (= 3 (find-path 3 12)))\r\n  (is (= 3 (find-path 12 3)))\r\n  (is (= 3 (find-path 5 9)))\r\n  (is (= 9 (find-path 9 2)))\r\n  (is (= 5 (find-path 9 12))))"
 "(deftest test-46\r\n  (is (= 3 ((flipper nth) 2 [1 2 3 4 5])))\r\n  (is (= true ((flipper >) 7 8)))\r\n  (is (= 4 ((flipper quot) 2 8)))\r\n  (is (= [1 2 3] ((flipper take) [1 2 3 4 5] 3))))"
 "(deftest functions-test\r\n  (is (= n ((fn add-five [x] (+ x 5)) 3)))\r\n  (is (= n ((fn [x] (+ x 5)) 3)))\r\n  (is (= n (#(+ % 5) 3)))\r\n  (is (= n ((partial + 5) 3))))"
 "(deftest test-117\r\n  (is (= true  (f [\"M   C\"])))\r\n  (is (= false (f [\"M # C\"])))\r\n  (is (= true  (f [\"#######\"\r\n                   \"#     #\"\r\n                   \"#  #  #\"\r\n                   \"#M # C#\"\r\n                   \"#######\"])))\r\n  (is (= false (f [\"########\"\r\n                   \"#M  #  #\"\r\n                   \"#   #  #\"\r\n                   \"# # #  #\"\r\n                   \"#   #  #\"\r\n                   \"#  #   #\"\r\n                   \"#  # # #\"\r\n                   \"#  #   #\"\r\n                   \"#  #  C#\"\r\n                   \"########\"])))\r\n  (is (= false (f [\"M     \"\r\n                   \"      \"\r\n                   \"      \"\r\n                   \"      \"\r\n                   \"    ##\"\r\n                   \"    #C\"])))\r\n  (is (= true  (f [\"C######\"\r\n                   \" #     \"\r\n                   \" #   # \"\r\n                   \" #   #M\"\r\n                   \"     # \"])))\r\n  (is (= true  (f [\"C# # # #\"\r\n                   \"        \"\r\n                   \"# # # # \"\r\n                   \"        \"\r\n                   \" # # # #\"\r\n                   \"        \"\r\n                   \"# # # #M\"]))))"
 "(deftest test-66\r\n  (is (= (gcd 2 4) 2))\r\n  (is (= (gcd 10 5) 5))\r\n  (is (= (gcd 5 7) 1))\r\n  (is (= (gcd 1023 858) 33)))"
 "(deftest test-29\r\n  (is (= (getcaps \"HeLlO, WoRlD!\") \"HLOWRD\"))\r\n  (is (empty? (getcaps \"nothing\")))\r\n  (is (= (getcaps \"$#A(*&987Zf\") \"AZ\")))"
 "(deftest test-38\r\n  (is (= (get-highest 1 8 3 4) 8))\r\n  (is (= (get-highest 30 20) 30))\r\n  (is (= (get-highest 45 67 11) 67)))"
 "(deftest test-91\r\n  (is (= true (graph #{[:a :a]})))\r\n  (is (= true (graph #{[:a :b]})))\r\n  (is (= false (graph #{[1 2] [2 3] [3 1]\r\n                        [4 5] [5 6] [6 4]})))\r\n  (is (= true (graph #{[1 2] [2 3] [3 1]\r\n                       [4 5] [5 6] [6 4] [3 4]})))\r\n  (is (= false (graph #{[:a :b] [:b :c] [:c :d]\r\n                        [:x :y] [:d :a] [:b :e]})))\r\n  (is (= true (graph #{[:a :b] [:b :c] [:c :d]\r\n                       [:x :y] [:d :a] [:b :e] [:x :a]}))))"
 "(deftest test-114\r\n  (is (= [2 3 5 7 11 13]\r\n         (gtw 4 #(= 2 (mod % 3))\r\n              [2 3 5 7 11 13 17 19 23])))\r\n  (is (= [\"this\" \"is\" \"a\" \"sentence\"]\r\n         (gtw 3 #(some #{\\i} %)\r\n              [\"this\" \"is\" \"a\" \"sentence\" \"i\" \"wrote\"])))\r\n  (is (= [\"this\" \"is\"]\r\n         (gtw 1 #{\"a\"}\r\n              [\"this\" \"is\" \"a\" \"sentence\" \"i\" \"wrote\"]))))"
 "(deftest test-49\r\n  (is (= (hack 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]]))\r\n  (is (= (hack 1 [:a :b :c :d]) [[:a] [:b :c :d]]))\r\n  (is (= (hack 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]])))"
 "(deftest test-83\r\n  (is (= false (half-truth false false)))\r\n  (is (= true (half-truth true false)))\r\n  (is (= false (half-truth true)))\r\n  (is (= true (half-truth false true false)))\r\n  (is (= false (half-truth true true true)))\r\n  (is (= true (half-truth true true true false))))"
 "(deftest test-86\r\n  (is (= (happy 7) true))\r\n  (is (= (happy 986543210) true))\r\n  (is (= (happy 2) false))\r\n  (is (= (happy 3) false)))"
 "(deftest hello-test\r\n  (is (= (hello \\\"Dave \\\") \\\"Hello, Dave!\\\"))\r\n  (is (= (hello \\\"Jenn \\\") \\\"Hello, Jenn! \\\"))\r\n  (is (= (hello \\\"Rhea \\\") \\\"Hello, Rhea! \\\")))"
 "(deftest test-40\r\n  (is (= (inject 0 [1 2 3]) [1 0 2 0 3]))\r\n  (is (= (apply str (inject \", \" [\"one\" \"two\" \"three\"])) \"one, two, three\"))\r\n  (is (= (inject :z [:a :b :c :d]) [:a :z :b :z :c :z :d])))"
 "(deftest test-171\r\n  (is (= (intervals [1 2 3]) [[1 3]]))\r\n  (is (= (intervals [10 9 8 1 2 3]) [[1 3] [8 10]]))\r\n  (is (= (intervals [1 1 1 1 1 1 1]) [[1 1]]))\r\n  (is (= (intervals []) []))\r\n  (is (= (intervals [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11])\r\n         [[1 4] [6 6] [9 11] [13 17] [19 19]])))"
 "(deftest test-105\r\n  (is (= {} (key-val [])))\r\n  (is (= {:a [1]} (key-val [:a 1])))\r\n  (is (= {:a [1], :b [2]} (key-val [:a 1, :b 2])))\r\n  (is (= {:a [1 2 3], :b [], :c [4]} (key-val [:a 1 2 3 :b :c 4]))))"
 "(deftest test-103\r\n  (is (= (k 1 #{4 5 6}) #{#{4} #{5} #{6}}))\r\n  (is (= (k 10 #{4 5 6}) #{}))\r\n  (is (= (k 2 #{0 1 2}) #{#{0 1} #{0 2} #{1 2}}))\r\n  (is (= (k 3 #{0 1 2 3 4}) #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4}\r\n                              #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}}))\r\n  (is (= (k 4 #{[1 2 3] :a \"abc\" \"efg\"}) #{#{[1 2 3] :a \"abc\" \"efg\"}}))\r\n  (is (= (k 2 #{[1 2 3] :a \"abc\" \"efg\"}) #{#{[1 2 3] :a} #{[1 2 3] \"abc\"} #{[1 2 3] \"efg\"}\r\n                                           #{:a \"abc\"} #{:a \"efg\"} #{\"abc\" \"efg\"}})))"
 "(deftest test-19\r\n  (is (= (my-last [1 2 3 4 5]) 5))\r\n  (is (= (my-last '(5 4 3)) 3))\r\n  (is (= (my-last [\"b\" \"c\" \"d\"]) \"d\")))"
 "(deftest test-108\r\n  (is (= 3 (lazy [3 4 5])))\r\n  (is (= 4 (lazy [1 2 3 4 5 6 7] [0.5 3/2 4 19])))\r\n  (is (= 64 (lazy (map #(* % % %) (range))\r\n                  (filter #(zero? (bit-and % (dec %))) (range))\r\n                  (iterate inc 20))))\r\n  (is (= 7 (lazy (range) (range 0 100 7/6) [2 3 5 7 11 13]))))"
 "(deftest test-100\r\n  (is (== (lcm 2 3) 6))\r\n  (is (== (lcm 5 3 7) 105))\r\n  (is (== (__ 1/3 2/5) 2))\r\n  (is (== (__ 3/4 1/6) 3/2))\r\n  (is (== (__ 7 5/7 2 3/5) 210)))"
 "(deftest test-101\r\n  (is (= (lev \"kitten\" \"sitting\") 3))\r\n  (is (= (lev \"closure\" \"clojure\") (lev \"clojure\" \"closure\") 1))\r\n  (is (= (lev \"xyx\" \"xyyyx\") 2))\r\n  (is (= (lev \"\" \"123456\") 6))\r\n  (is (= (lev \"Clojure\" \"Clojure\") (lev \"\" \"\") (lev [] []) 0))\r\n  (is (= (lev [1 2 3 4] [0 2 3 4 5]) 2))\r\n  (is (= (lev '(:a :b :c :d) '(:a :d)) 2))\r\n  (is (= (lev \"ttttattttctg\" \"tcaaccctaccat\") 10))\r\n  (is (= (lev \"gaattctaatctc\" \"caaacaaaaaattt\") 9)))"
 "(deftest lists-test\r\n  (is (= l '(:a :b :c))))"
 "(deftest test-127\r\n  (is (= 10 (lt [15 15 15 15 15])))\r\n; 1111      1111\r\n; 1111      *111\r\n; 1111  ->  **11\r\n; 1111      ***1\r\n; 1111      ****\r\n  (is (= 15 (lt [1 3 7 15 31])))\r\n; 00001      0000*\r\n; 00011      000**\r\n; 00111  ->  00***\r\n; 01111      0****\r\n; 11111      *****\r\n  (is (= 3 (lt [3 3])))\r\n; 11      *1\r\n; 11  ->  **\r\n  (is (= 4 (lt [7 3])))\r\n; 111      ***\r\n; 011  ->  0*1\r\n  (is (= 6 (lt [17 22 6 14 22])))\r\n; 10001      10001\r\n; 10110      101*0\r\n; 00110  ->  00**0\r\n; 01110      0***0\r\n; 10110      10110\r\n  (is (= 9 (lt [18 7 14 14 6 3])))\r\n; 10010      10010\r\n; 00111      001*0\r\n; 01110      01**0\r\n; 01110  ->  0***0\r\n; 00110      00**0\r\n; 00011      000*1\r\n  (is (= nil (lt [21 10 21 10])))\r\n; 10101      10101\r\n; 01010      01010\r\n; 10101  ->  10101\r\n; 01010      01010\r\n  (is (= nil (lt [0 31 0 31 0]))))\r\n; 00000      00000\r\n; 11111      11111\r\n; 00000  ->  00000\r\n; 11111      11111\r\n; 00000      00000"
 ...)
clj꞉user꞉> 
#'user/test-all
clj꞉user꞉> 
"{\r\n  \"find_path\" : \"(defn find-path [s e]\\r\\n  (loop [opts [s] depth 1]\\r\\n    (if (some #{e} opts)\\r\\n      depth\\r\\n      (letfn [(solutions [n]\\r\\n                (concat\\r\\n                 [(* n 2) (+ n 2)]\\r\\n                 (if (even? n) [(/ n 2)] [])))]\\r\\n        (recur (mapcat solutions opts) (inc depth))))))\",\r\n  \"compress\" : \"(defn compress [s]\\r\\n  (map first\\r\\n       (partition-by identity s)))\",\r\n  \"map\" : \"(def l '(1 2 3))\",\r\n  \"vectors\" : \"(def v [])\",\r\n  \"ttt\" : \"(defn ttt [board]\\r\\n  (some {[:x :x :x] :x [:o :o :o] :o}\\r\\n        (concat board (apply map list board)\\r\\n                (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\\r\\n                  (for [[x y] d] ((board x) y))))))\",\r\n  \"pf\" : \"(defn pf [s]\\r\\n  (if (every? coll? s)\\r\\n    (mapcat pf s)\\r\\n    [s]))\",\r\n  \"get_highest\" : \"(defn get-highest [& all]\\r\\n  (last (sort all)))\",\r\n  \"penultimate\" : \"(defn penultimate [s]\\r\\n  (second (reverse s)))\",\r\n  \"dupseq\" : \"(defn dupseq [s]\\r\\n  (interleave s s))\",\r\n  \"digits\" : \"(defn digits [x y]\\r\\n  (map #(- (int %) (int \\\\0)) (str (* x y))))\",\r\n  \"primes\" : \"(defn primes [n]\\r\\n  (->>\\r\\n   (range)\\r\\n   (drop 2)\\r\\n   (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\\r\\n   (take n)))\",\r\n  \"getcaps\" : \"(defn getcaps [s]\\r\\n  (apply str (re-seq #\\\"[A-Z]\\\" s)))\",\r\n  \"roman\" : \"(defn roman [x]\\r\\n  (cond\\r\\n    (<= 1000 x) (str \\\"M\\\" (roman (- x 1000)))\\r\\n    (<= 900 x) (str \\\"CM\\\" (roman (- x 900)))\\r\\n    (<= 500 x) (str \\\"D\\\" (roman (- x 500)))\\r\\n    (<= 400 x) (str \\\"CD\\\" (roman (- x 400)))\\r\\n    (<= 100 x) (str \\\"C\\\" (roman (- x 100)))\\r\\n    (<= 90 x) (str \\\"XC\\\" (roman (- x 90)))\\r\\n    (<= 50 x) (str \\\"L\\\" (roman (- x 50)))\\r\\n    (<= 40 x) (str \\\"XL\\\" (roman (- x 40)))\\r\\n    (<= 10 x) (str \\\"X\\\" (roman (- x 10)))\\r\\n    (<= 9 x) (str \\\"IX\\\" (roman (- x 9)))\\r\\n    (<= 5 x) (str \\\"V\\\" (roman (- x 5)))\\r\\n    (<= 4 x) (str \\\"IV\\\" (roman (- x 4)))\\r\\n    (<= 1 x) (str \\\"I\\\" (roman (- x 1)))\\r\\n    true \\\"\\\"))\",\r\n  \"totient\" : \"(defn totient [a]\\r\\n  (count\\r\\n   (for [b (range a)\\r\\n         :when (not-any? #(= 0 (rem a %) (rem b %)) (range 2 a))]\\r\\n     b)))\",\r\n  \"lists\" : \"(def l (list 1 2 3))\",\r\n  \"hello\" : \"(defn hello [name]\\r\\n  )\",\r\n  \"symmetric\" : \"(defn symmetric? [t]\\r\\n  (= t ((fn m [[v l r]] (if v [v (m r) (m l)])) t)))\",\r\n  \"lt\" : \"(defn lt [b]\\r\\n  (let [z (apply max 0\\r\\n                 (for [b [b (vec (reverse b))]\\r\\n                       y (range (count b))\\r\\n                       x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\\r\\n                       [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\\r\\n                       :let [s (loop [m m\\r\\n                                      d [i a]\\r\\n                                      [l h :as r] [x x]\\r\\n                                      s 0\\r\\n                                      [w & e :as b] (drop y b)]\\r\\n                                 (cond\\r\\n                                   (and w (>= l 0) (every? #(bit-test w %) (range l (inc h))))\\r\\n                                   (recur m d (map + d r) (+ s 1 (- h l)) e)\\r\\n                                   (< h l) s\\r\\n                                   (= 0 m) s\\r\\n                                   (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\\r\\n                       :when s]\\r\\n                   s))]\\r\\n    (when (> z 1) z)))\",\r\n  \"maths\" : \"(def expr (= (- 10 (* 2 3)) n))\",\r\n  \"strings\" : \"(def s (. \\\"'goodbye'.toUpperCase\\\"))\",\r\n  \"f\" : \"(defn f [grid]\\r\\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\\r\\n        parts (for [y (range (count grid))\\r\\n                    x (range (count (nth grid y)))\\r\\n                    :let [e (get-in grid [y x])]]\\r\\n                {({\\\\C :cat \\\\M :mouse \\\\# :wall \\\\space :space} e) [x y]})\\r\\n        game (apply merge-with conj {:wall [] :space []} parts)\\r\\n        spaces (conj (set (:space game)) (:mouse game))]\\r\\n    (loop [open [(:cat game)] visited #{}]\\r\\n      (cond\\r\\n        (empty? open) false\\r\\n        (= (first open) (:mouse game)) true\\r\\n        :else (let [visited (conj visited (first open))\\r\\n                    neigh (filter spaces (neighbors (first open)))\\r\\n                    neigh (remove visited neigh)\\r\\n                    open (concat (rest open) (remove visited neigh))]\\r\\n                (recur open visited))))))\",\r\n  \"drop_every_nth\" : \"(defn drop-every-nth [s n]\\r\\n  (apply concat (partition-all (dec n) n s)))\",\r\n  \"my_merge_with\" : \"(defn my-merge-with [f & ms]\\r\\n  (reduce (fn [am m]\\r\\n            (into am (for [[k v] m]\\r\\n                       (if (contains? am k)\\r\\n                         [k (f (am k) v)]\\r\\n                         [k v]))))\\r\\n          ms))\",\r\n  \"deinterleave\" : \"(defn deinterleave [coll n]\\r\\n  (apply map list (partition n coll)))\",\r\n  \"my_trampoline\" : \"(defn my-trampoline [f & x]\\r\\n  (if (fn? f)\\r\\n    (my-trampoline (apply f x))\\r\\n    f))\",\r\n  \"pascal\" : \"(defn pascal [n]\\r\\n  (loop [x 1 l [1]]\\r\\n    (if (= x n) l\\r\\n        (recur (inc x) (vec (map + (cons 0 l) (conj l 0)))))))\",\r\n  \"cw\" : \"(defn cw [word board]\\r\\n  (let [across (map #(clojure.string/escape % {\\\\space \\\"\\\", \\\\_ \\\\.}) board)\\r\\n        down (apply map str across)]   ;; transpose the board so down becomes across\\r\\n    (string? (->> (concat across down)\\r\\n                  (mapcat #(clojure.string/split % #\\\"#\\\"))\\r\\n                  (some #(re-matches (re-pattern %) word))))))\",\r\n  \"pack\" : \"(defn pack [s]\\r\\n  (partition-by identity s))\",\r\n  \"powerset\" : \"(defn powerset [s]\\r\\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))\",\r\n  \"lcm\" : \"(defn lcm [& args]\\r\\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\\r\\n    (/ (reduce * args) (reduce gcd args))))\",\r\n  \"anagram\" : \"(defn anagram [c]\\r\\n  (set (for [[_ g] (group-by frequencies c)\\r\\n             :when (next g)]\\r\\n         (set g))))\",\r\n  \"ss\" : \"(defn ss [coll]\\r\\n  (let [digits (fn digits [n]\\r\\n                 (if (< n 10)\\r\\n                   (list n)\\r\\n                   (cons (rem n 10) (digits (quot n 10)))))]\\r\\n    (count (filter\\r\\n            #(< % (apply + (map * (digits %) (digits %))))\\r\\n            coll))))\",\r\n  \"graph\" : \"(defn graph [g]\\r\\n  ((fn f [e]\\r\\n     (#(if (= e %) (= % g) (f %))\\r\\n      (reduce (fn [a b] (into a (filter #(some (set b) %) g)))\\r\\n              #{}\\r\\n              e)))\\r\\n   #{(first g)}))\",\r\n  \"set_sect\" : \"(defn set-sect [a b]\\r\\n  (set (filter a b)))\",\r\n  \"flipper\" : \"(defn flipper [f]\\r\\n  #(f %2 %))\",\r\n  \"word_chain\" : \"(defn word-chain [s]\\r\\n  (or (some (fn [w]\\r\\n              ((fn f [a s]\\r\\n                 (or (empty? s)\\r\\n                     (some #(if (loop [[a & b :as c] (seq a) [d & e :as g] (seq %)]\\r\\n                                  (if (= a d)\\r\\n                                    (recur b e)\\r\\n                                    (or (= b e) (= b g) (= c e))))\\r\\n                              (f % (disj s %)))\\r\\n                           s)))\\r\\n               w (disj s w)))\\r\\n            s)\\r\\n      false))\",\r\n  \"ps\" : \"(defn ps [n]\\r\\n  (first (for [o (range 1 (- n 2))\\r\\n               [a b c] [(for [x [(- n o) (+ n o) n]]\\r\\n                          (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\\r\\n               :when (or a b)]\\r\\n           (and a b c))))\",\r\n  \"maps\" : \"(def n 0)\",\r\n  \"seq_prons\" : \"(defn seq-prons [s]\\r\\n  (next (iterate #(mapcat (juxt count first)\\r\\n                          (partition-by identity %)) s)))\",\r\n  \"hack\" : \"(defn hack [n s]\\r\\n  [(take n s) (drop n s)])\",\r\n  \"reverse_seq\" : \"(defn reverse-seq [s]\\r\\n  (reduce conj () s))\",\r\n  \"makeflat\" : \"(defn makeflat [s]\\r\\n  (filter (complement sequential?)\\r\\n          (rest (tree-seq sequential? seq s))))\",\r\n  \"rest\" : \"(def v [10 20 30 40])\",\r\n  \"perfect_nums\" : \"(defn perfect-nums [x]\\r\\n  (= x (apply + (filter #(= 0 (mod x %)) (range 1 x)))))\",\r\n  \"closure\" : \"(defn closure [n] #(apply * (repeat n %)))\",\r\n  \"intervals\" : \"(defn intervals [coll]\\r\\n  (reverse (reduce (fn [[[a b] & r :as is] n]\\r\\n                     (if (and a (= (inc b) n))\\r\\n                       (cons [a n] r)\\r\\n                       (cons [n n] is)))\\r\\n                   ()\\r\\n                   (distinct (sort coll)))))\",\r\n  \"gtw\" : \"(defn gtw [n p [x & r]]\\r\\n  (lazy-seq\\r\\n   (when x\\r\\n     (let [remaining (if (p x) (dec n) n)]\\r\\n       (when (pos? remaining)\\r\\n         (cons x (gtw remaining p r)))))))\",\r\n  \"conj_list\" : \"(def l '(3 4))\",\r\n  \"camel\" : \"(defn camel [s]\\r\\n  (let [words (re-seq #\\\"[a-zA-Z]+\\\" s)\\r\\n        words (cons (first words)\\r\\n                    (map clojure.string/capitalize\\r\\n                         (rest words)))]\\r\\n    (apply str words)))\",\r\n  \"splatter\" : \"(defn splatter [s n]\\r\\n  (mapcat\\r\\n   (fn [s]\\r\\n     (repeat n s)) s))\",\r\n  \"split_by_type\" : \"(defn split-by-type [s]\\r\\n  (vals (group-by type s)))\",\r\n  \"gcd\" : \"(defn gcd [a b]\\r\\n  (if (= 0 b) a (recur b (mod a b))))\",\r\n  \"conj_map\" : \"(def kv [:a 1])\",\r\n  \"tree\" : \"(defn tree? [n]\\r\\n  (or (nil? n)\\r\\n      (and (coll? n)\\r\\n           (= 3 (count n))\\r\\n           (every? tree? (rest n)))))\",\r\n  \"key_val\" : \"(defn key-val [c]\\r\\n  (loop [[f & r] c, kvm {}]\\r\\n    (if (nil? f)\\r\\n      kvm\\r\\n      (let [[vs l] (split-with (complement keyword?) r)]\\r\\n        (recur l (assoc kvm f vs))))))\",\r\n  \"mymap\" : \"(defn mymap [f l]\\r\\n  (rest (reductions #(f %2) 0 l)))\",\r\n  \"classes\" : \"(defn classes [f c]\\r\\n  (set (map set (vals (group-by f c)))))\",\r\n  \"bin\" : \"(defn bin [n]\\r\\n  (apply + (map #(if (= \\\\1 %1)\\r\\n                   (apply * (repeat %2 2)) 0)\\r\\n                (reverse n) (range))))\",\r\n  \"myrange\" : \"(defn myrange [a b]\\r\\n  (take (- b a) (iterate inc a)))\",\r\n  \"conj_vector\" : \"(def v [1 2])\",\r\n  \"my_interleave\" : \"(defn my-interleave [a b]\\r\\n  (mapcat list a b))\",\r\n  \"factorial\" : \"(defn factorial [n]\\r\\n  (reduce * (range 1 (inc n))))\",\r\n  \"filter\" : \"(def l '(3 4 5 6 7))\",\r\n  \"functions\" : \"(def n 0)\",\r\n  \"seqs\" : \"(def n 0)\",\r\n  \"uce\" : \"(defn uce [x]\\r\\n  (fn [m] ((fn e [x m]\\r\\n             (if (seq? x)\\r\\n               (apply ({'+ + '- - '* * '/ /} (first x))\\r\\n                      (map #(e % m) (rest x)))\\r\\n               (m x x)))\\r\\n           x m)))\",\r\n  \"make_map\" : \"(defn make-map [keys vals]\\r\\n  (apply hash-map (interleave keys vals)))\",\r\n  \"my_group_by\" : \"(defn my-group-by [f s]\\r\\n  (reduce\\r\\n   (fn [m x] (assoc m (f x) (conj (m (f x) []) x)))\\r\\n   {} s))\",\r\n  \"fib\" : \"(defn fib [a b]\\r\\n  (lazy-seq (cons a (fib b (+ a b)))))\",\r\n  \"shifter\" : \"(defn shifter [n s]\\r\\n  (take (count s) (drop (mod n (count s)) (cycle s))))\",\r\n  \"nth_element\" : \"(defn nth-element [s n]\\r\\n  (last (take (inc n) s)))\",\r\n  \"truth\" : \"(def truth (= false true))\",\r\n  \"last\" : \"(defn my-last [s]\\r\\n  (if (next s)\\r\\n    (recur (next s))\\r\\n    (first s)))\",\r\n  \"spaz_out\" : \"(defn spaz-out [f init]\\r\\n  (cons init\\r\\n        (lazy-seq\\r\\n         (spaz-out f (f init)))))\",\r\n  \"mycomp\" : \"(defn mycomp [f & gs]\\r\\n  (if gs\\r\\n    #(f (apply (apply mycomp gs) (conj %& %)))\\r\\n    f))\",\r\n  \"k\" : \"(defn k [i s]\\r\\n  (set\\r\\n   (if (= i 0)\\r\\n     [#{}]\\r\\n     (mapcat #(for [p (k (- i 1) %2)] (conj p %))\\r\\n             s (next (iterate next s))))))\",\r\n  \"myreductions\" : \"(defn my-reductions\\r\\n  ([f [a & b]] (my-reductions f a b))\\r\\n  ([f a b]\\r\\n   (let [m (atom a)]\\r\\n     (cons a (map #(swap! m f %) b)))))\",\r\n  \"conj_set\" : \"(def n 0)\",\r\n  \"double\" : \"(def f \\r\\n  (fn [n]\\r\\n    ))\",\r\n  \"sym_diff\" : \"(defn sym-diff [a b]\\r\\n  (into (set (remove b a)) (remove a b)))\",\r\n  \"tri_path\" : \"(defn tri-path [s]\\r\\n  (first\\r\\n   (reduce\\r\\n    #(map + (map min (butlast %1) (rest %1)) %2)\\r\\n    (reverse s))))\",\r\n  \"db\" : \"(defn digits [n b]\\r\\n  (if (< n b)\\r\\n    [n]\\r\\n    (conj (digits (quot n b) b) (rem n b))))\",\r\n  \"sets\" : \"(def s #{:a :b :c})\",\r\n  \"mypal\" : \"(defn mypal [s]\\r\\n  (= (seq s) (reverse (seq s))))\",\r\n  \"cartesian\" : \"(defn cartesian [x y]\\r\\n  (set (for [a x b y] [a b])))\",\r\n  \"perfect_square\" : \"(defn perfect-square [s]\\r\\n  (let [l (re-seq #\\\"\\\\d+\\\" s)]\\r\\n    (clojure.string/join \\\",\\\" (filter #{\\\"4\\\" \\\"9\\\" \\\"16\\\" \\\"25\\\" \\\"36\\\"} l))))\",\r\n  \"inject\" : \"(defn inject [x coll]\\r\\n  (rest (interleave (repeat x) coll)))\",\r\n  \"word_sort\" : \"(defn word-sort [s]\\r\\n  (sort-by #(.toLowerCase %) (re-seq #\\\"\\\\w+\\\" s)))\",\r\n  \"reversi\" : \"(defn reversi [board p]\\r\\n  (let [o '{b w w b}\\r\\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\\r\\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\\r\\n        e (map key (filter #(= 'e (val %)) b))\\r\\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\\r\\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \\\"+\\\" p))]\\r\\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\\r\\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\\r\\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))\",\r\n  \"lazy\" : \"(defn lazy [& s]\\r\\n  (loop [v (vec s)]\\r\\n    (let [first-vals (map first v)\\r\\n          smallest (apply min first-vals)]\\r\\n      (if (= smallest (apply max first-vals))\\r\\n        smallest\\r\\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\\r\\n          (recur (update-in v [i] next)))))))\",\r\n  \"sh\" : \"(defn sh [n [x & r]]\\r\\n  (if x\\r\\n    (if (sequential? x)\\r\\n      (let [sub (sh n x)]\\r\\n        (cons sub (sh (- n (reduce + (flatten sub))) r)))\\r\\n      (if (<= x n)\\r\\n        (cons x (sh (- n x) r))\\r\\n        ()))))\",\r\n  \"half_truth\" : \"(defn half-truth [& vs]\\r\\n  (true? (and (some not vs)\\r\\n              (some identity vs))))\",\r\n  \"longest_subseq\" : \"(defn longest-subseq [s]\\r\\n  (or (first (for [l (reverse (range 2 (count s)))\\r\\n                   f (filter #(apply < %) (partition l 1 s))]\\r\\n               f)) []))\",\r\n  \"quine\" : \"(defn quine []\\r\\n  (fn []\\r\\n    (let [x '(list 'fn []\\r\\n                   (list 'let ['x (list 'quote x)]\\r\\n                         (list 'str x)))]\\r\\n      (str (list 'fn []\\r\\n                 (list 'let ['x (list 'quote x)]\\r\\n                       (list 'str x)))))))\",\r\n  \"eulerian\" : \"(defn eulerian [e]\\r\\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\\r\\n    (not (next (reduce\\r\\n                (fn [g e]\\r\\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\\r\\n                    (conj (disj g a b) (into a b))))\\r\\n                #{}\\r\\n                e)))\\r\\n    false))\",\r\n  \"cards\" : \"(defn cards [c]\\r\\n  {:suit ({\\\\H :heart \\\\C :club \\\\S :spade \\\\D :diamond} (first c))\\r\\n   :rank ((zipmap \\\"23456789TJQKA\\\" (range)) (second c))})\",\r\n  \"rn\" : \"(defn rn [n]\\r\\n  (->> (map {\\\\C 100 \\\\D 500 \\\\I 1 \\\\L 50 \\\\M 1000 \\\\V 5 \\\\X 10} n)\\r\\n       (partition 2 1 [0])\\r\\n       (map (fn [[a b]] (if (< a b) (- a) a)))\\r\\n       (apply +)))\",\r\n  \"count_elements\" : \"(defn count-elements [s]\\r\\n  (loop [x s acc 0]\\r\\n    (if (empty? x)\\r\\n      acc\\r\\n      (recur (rest x) (inc acc)))))\",\r\n  \"happy\" : \"(defn happy [n]\\r\\n  (loop [n n\\r\\n         s #{}]\\r\\n    (let [x (apply + (map #(let [i (- (int %) (int \\\\0))] (* i i)) (str n)))]\\r\\n      (cond (= x 1) true\\r\\n            (s x) false\\r\\n            :else (recur x (conj s x))))))\",\r\n  \"bal_num\" : \"(defn bal-num [n]\\r\\n  (let [s (map #(- (int %) 48) (str n))\\r\\n        l (/ (count s) 2)\\r\\n        [a b] (map #(apply + (take l %)) [s (into () s)])]\\r\\n    (= a b)))\",\r\n  \"lev\" : \"(defn lev [s t]\\r\\n  (let [f (fn [f s t]\\r\\n            (cond\\r\\n              (empty? s) (count t)\\r\\n              (empty? t) (count s)\\r\\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\\r\\n                      (min (inc (f f (rest s) t))\\r\\n                           (inc (f f s (rest t)))\\r\\n                           (+ cost (f f (rest s) (rest t)))))))\\r\\n        g (memoize f)]\\r\\n    (g g s t)))\",\r\n  \"black_box\" : \" (defn black-box [c]\\r\\n  ((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))\",\r\n  \"myjuxt\" : \"(defn myjuxt [& f]\\r\\n  (fn [& a]\\r\\n    (map #(apply % a) f)))\",\r\n  \"trans_closure\" : \"(defn trans-closure [r]\\r\\n  (loop [s r]\\r\\n    (let [n (into s\\r\\n                  (for [[a b] s [c d] s\\r\\n                        :when (= b c)]\\r\\n                    [a d]))]\\r\\n      (if (= n s) n (recur n)))))\",\r\n  \"conway\" : \"(defn conway [board]\\r\\n  (let [r (range (count board))\\r\\n        v [-1 0 1]\\r\\n        a \\\\#]\\r\\n    (for [y r]\\r\\n      (apply str (for [x r c [(count\\r\\n                               (for [j v\\r\\n                                     k v\\r\\n                                     :when (= a (get-in board [(+ y j) (+ x k)]))]\\r\\n                                 1))]]\\r\\n                   (if (or (= c 3) (and (= c 4) (= a (get-in board [y x]))))\\r\\n                     a\\r\\n                     \\\\ ))))))\",\r\n  \"veitch\" : \"(defn veitch [I]\\r\\n  (disj (into #{} (map (fn [s]\\r\\n                         ((reduce\\r\\n                           (fn [[d f u] x]\\r\\n                             (let [U (disj u x)\\r\\n                                   m (fn [t] (map #(conj % t) f))\\r\\n                                   P #(symbol (.toUpperCase (str %)))\\r\\n                                   L #(symbol (.toLowerCase (str %)))\\r\\n                                   F (into (m (L x)) (m (P x)))]\\r\\n                               (if (every? #(contains? I %) (map #(into (into d U) %) F))\\r\\n                                 [d F U]\\r\\n                                 [(conj d x) f U])))\\r\\n                           [#{} [#{}] s]\\r\\n                           s) 0)) I))\\r\\n        '#{A d}))\",\r\n  \"ttt2\" : \"(defn ttt [p board]\\r\\n  (let [win? #(let [b (concat % (apply map list %)\\r\\n                              [(map nth % (range)) (map nth (map reverse %) (range))])]\\r\\n                (some #{[p p p]} b))]\\r\\n    (set\\r\\n     (for [y (range 3), x (range 3),\\r\\n           :when (and (= :e (get-in board [y x]))\\r\\n                      (win? (assoc-in board [y x] p)))]\\r\\n       [y x]))))\"\r\n}"
clj꞉user꞉> 
nil
clj꞉user꞉> 
nil
clj꞉user꞉> 
