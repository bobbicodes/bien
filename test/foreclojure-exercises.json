{
  "find_path" : "(defn find-path [s e]\r\n  (loop [opts [s] depth 1]\r\n    (if (some #{e} opts)\r\n      depth\r\n      (letfn [(solutions [n]\r\n                (concat\r\n                 [(* n 2) (+ n 2)]\r\n                 (if (even? n) [(/ n 2)] [])))]\r\n        (recur (mapcat solutions opts) (inc depth))))))",
  "compress" : "(defn compress [s]\r\n  (map first\r\n       (partition-by identity s)))",
  "map" : "(def l '(1 2 3))", 
  "vectors" : "(def v [:a :b :c])",
  "ttt" : "(defn ttt [board]\r\n  (some {[:x :x :x] :x [:o :o :o] :o}\r\n        (concat board (apply map list board)\r\n                (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\r\n                  (for [[x y] d] ((board x) y))))))",
  "pf" : "(defn pf [s]\r\n  (if (every? coll? s)\r\n    (mapcat pf s)\r\n    [s]))",
  "get_highest" : "(defn get-highest [& all]\r\n  (last (sort all)))",
  "penultimate" : "(defn penultimate [s]\r\n  (second (reverse s)))",
  "dupseq" : "(defn dupseq [s]\r\n  (interleave s s))",
  "digits" : "(defn digits [x y]\r\n  (map #(- (int %) (int \\0)) (str (* x y))))",
  "primes" : "(defn primes [n]\r\n  (->>\r\n   (range)\r\n   (drop 2)\r\n   (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\r\n   (take n)))",
  "getcaps" : "(defn getcaps [s]\r\n  (apply str (re-seq #\"[A-Z]\" s)))",
  "roman" : "(defn roman [x]\r\n  (cond\r\n    (<= 1000 x) (str \"M\" (roman (- x 1000)))\r\n    (<= 900 x) (str \"CM\" (roman (- x 900)))\r\n    (<= 500 x) (str \"D\" (roman (- x 500)))\r\n    (<= 400 x) (str \"CD\" (roman (- x 400)))\r\n    (<= 100 x) (str \"C\" (roman (- x 100)))\r\n    (<= 90 x) (str \"XC\" (roman (- x 90)))\r\n    (<= 50 x) (str \"L\" (roman (- x 50)))\r\n    (<= 40 x) (str \"XL\" (roman (- x 40)))\r\n    (<= 10 x) (str \"X\" (roman (- x 10)))\r\n    (<= 9 x) (str \"IX\" (roman (- x 9)))\r\n    (<= 5 x) (str \"V\" (roman (- x 5)))\r\n    (<= 4 x) (str \"IV\" (roman (- x 4)))\r\n    (<= 1 x) (str \"I\" (roman (- x 1)))\r\n    true \"\"))",
  "totient" : "(defn totient [a]\r\n  (count\r\n   (for [b (range a)\r\n         :when (not-any? #(= 0 (rem a %) (rem b %)) (range 2 a))]\r\n     b)))",
  "lists" : "(def l (list 1 2 3))",
  "hello" : "(defn hello [name]\r\n  )",
  "symmetric" : "(defn symmetric? [t]\r\n  (= t ((fn m [[v l r]] (if v [v (m r) (m l)])) t)))",
  "lt" : "(defn lt [b]\r\n  (let [z (apply max 0\r\n                 (for [b [b (vec (reverse b))]\r\n                       y (range (count b))\r\n                       x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\r\n                       [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\r\n                       :let [s (loop [m m\r\n                                      d [i a]\r\n                                      [l h :as r] [x x]\r\n                                      s 0\r\n                                      [w & e :as b] (drop y b)]\r\n                                 (cond\r\n                                   (and w (>= l 0) (every? #(bit-test w %) (range l (inc h))))\r\n                                   (recur m d (map + d r) (+ s 1 (- h l)) e)\r\n                                   (< h l) s\r\n                                   (= 0 m) s\r\n                                   (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\r\n                       :when s]\r\n                   s))]\r\n    (when (> z 1) z)))",
  "maths" : "(def expr (= (- 10 (* 2 3)) n))",
  "strings" : "(def s (. \"'goodbye'.toUpperCase\"))",
  "f" : "(defn f [grid]\r\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\r\n        parts (for [y (range (count grid))\r\n                    x (range (count (nth grid y)))\r\n                    :let [e (get-in grid [y x])]]\r\n                {({\\C :cat \\M :mouse \\# :wall \\space :space} e) [x y]})\r\n        game (apply merge-with conj {:wall [] :space []} parts)\r\n        spaces (conj (set (:space game)) (:mouse game))]\r\n    (loop [open [(:cat game)] visited #{}]\r\n      (cond\r\n        (empty? open) false\r\n        (= (first open) (:mouse game)) true\r\n        :else (let [visited (conj visited (first open))\r\n                    neigh (filter spaces (neighbors (first open)))\r\n                    neigh (remove visited neigh)\r\n                    open (concat (rest open) (remove visited neigh))]\r\n                (recur open visited))))))",
  "drop_every_nth" : "(defn drop-every-nth [s n]\r\n  (apply concat (partition-all (dec n) n s)))",
  "my_merge_with" : "(defn my-merge-with [f & ms]\r\n  (reduce (fn [am m]\r\n            (into am (for [[k v] m]\r\n                       (if (contains? am k)\r\n                         [k (f (am k) v)]\r\n                         [k v]))))\r\n          ms))",
  "deinterleave" : "(defn deinterleave [coll n]\r\n  (apply map list (partition n coll)))",
  "my_trampoline" : "(defn my-trampoline [f & x]\r\n  (if (fn? f)\r\n    (my-trampoline (apply f x))\r\n    f))",
  "pascal" : "(defn pascal [n]\r\n  (loop [x 1 l [1]]\r\n    (if (= x n) l\r\n        (recur (inc x) (vec (map + (cons 0 l) (conj l 0)))))))",
  "cw" : "(defn cw [word board]\r\n  (let [across (map #(clojure.string/escape % {\\space \"\", \\_ \\.}) board)\r\n        down (apply map str across)]   ;; transpose the board so down becomes across\r\n    (string? (->> (concat across down)\r\n                  (mapcat #(clojure.string/split % #\"#\"))\r\n                  (some #(re-matches (re-pattern %) word))))))",
  "pack" : "(defn pack [s]\r\n  (partition-by identity s))",
  "powerset" : "(defn powerset [s]\r\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))",
  "lcm" : "(defn lcm [& args]\r\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (/ (reduce * args) (reduce gcd args))))",
  "anagram" : "(defn anagram [c]\r\n  (set (for [[_ g] (group-by frequencies c)\r\n             :when (next g)]\r\n         (set g))))",
  "ss" : "(defn ss [coll]\r\n  (let [digits (fn digits [n]\r\n                 (if (< n 10)\r\n                   (list n)\r\n                   (cons (rem n 10) (digits (quot n 10)))))]\r\n    (count (filter\r\n            #(< % (apply + (map * (digits %) (digits %))))\r\n            coll))))",
  "graph" : "(defn graph [g]\r\n  ((fn f [e]\r\n     (#(if (= e %) (= % g) (f %))\r\n      (reduce (fn [a b] (into a (filter #(some (set b) %) g)))\r\n              #{}\r\n              e)))\r\n   #{(first g)}))",
  "set_sect" : "(defn set-sect [a b]\r\n  (set (filter a b)))",
  "flipper" : "(defn flipper [f]\r\n  #(f %2 %))",
  "word_chain" : "(defn word-chain [s]\r\n  (or (some (fn [w]\r\n              ((fn f [a s]\r\n                 (or (empty? s)\r\n                     (some #(if (loop [[a & b :as c] (seq a) [d & e :as g] (seq %)]\r\n                                  (if (= a d)\r\n                                    (recur b e)\r\n                                    (or (= b e) (= b g) (= c e))))\r\n                              (f % (disj s %)))\r\n                           s)))\r\n               w (disj s w)))\r\n            s)\r\n      false))",
  "ps" : "(defn ps [n]\r\n  (first (for [o (range 1 (- n 2))\r\n               [a b c] [(for [x [(- n o) (+ n o) n]]\r\n                          (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\r\n               :when (or a b)]\r\n           (and a b c))))",
  "maps" : "(def n 0)",
  "seq_prons" : "(defn seq-prons [s]\r\n  (next (iterate #(mapcat (juxt count first)\r\n                          (partition-by identity %)) s)))",
  "hack" : "(defn hack [n s]\r\n  [(take n s) (drop n s)])",
  "reverse_seq" : "(defn reverse-seq [s]\r\n  (reduce conj () s))",
  "makeflat" : "(defn makeflat [s]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq s))))",
  "rest" : "(def v [10 20 30 40])",
  "perfect_nums" : "(defn perfect-nums [x]\r\n  (= x (apply + (filter #(= 0 (mod x %)) (range 1 x)))))",
  "closure" : "(defn closure [n] #(apply * (repeat n %)))",
  "intervals" : "(defn intervals [coll]\r\n  (reverse (reduce (fn [[[a b] & r :as is] n]\r\n                     (if (and a (= (inc b) n))\r\n                       (cons [a n] r)\r\n                       (cons [n n] is)))\r\n                   ()\r\n                   (distinct (sort coll)))))",
  "gtw" : "(defn gtw [n p [x & r]]\r\n  (lazy-seq\r\n   (when x\r\n     (let [remaining (if (p x) (dec n) n)]\r\n       (when (pos? remaining)\r\n         (cons x (gtw remaining p r)))))))",
  "conj_list" : "(def l '(3 4))",
  "camel" : "(defn camel [s]\r\n  (let [words (re-seq #\"[a-zA-Z]+\" s)\r\n        words (cons (first words)\r\n                    (map clojure.string/capitalize\r\n                         (rest words)))]\r\n    (apply str words)))",
  "splatter" : "(defn splatter [s n]\r\n  (mapcat\r\n   (fn [s]\r\n     (repeat n s)) s))",
  "split_by_type" : "(defn split-by-type [s]\r\n  (vals (group-by type s)))",
  "gcd" : "(defn gcd [a b]\r\n  (if (= 0 b) a (recur b (mod a b))))",
  "conj_map" : "(def kv [:a 1])",
  "tree" : "(defn tree? [n]\r\n  (or (nil? n)\r\n      (and (coll? n)\r\n           (= 3 (count n))\r\n           (every? tree? (rest n)))))",
  "key_val" : "(defn key-val [c]\r\n  (loop [[f & r] c, kvm {}]\r\n    (if (nil? f)\r\n      kvm\r\n      (let [[vs l] (split-with (complement keyword?) r)]\r\n        (recur l (assoc kvm f vs))))))",
  "mymap" : "(defn mymap [f l]\r\n  (rest (reductions #(f %2) 0 l)))",
  "classes" : "(defn classes [f c]\r\n  (set (map set (vals (group-by f c)))))",
  "bin" : "(defn bin [n]\r\n  (apply + (map #(if (= \\1 %1)\r\n                   (apply * (repeat %2 2)) 0)\r\n                (reverse n) (range))))",
  "myrange" : "(defn myrange [a b]\r\n  (take (- b a) (iterate inc a)))",
  "conj_vector" : "(def v [1 2])",
  "my_interleave" : "(defn my-interleave [a b]\r\n  (mapcat list a b))",
  "factorial" : "(defn factorial [n]\r\n  (reduce * (range 1 (inc n))))",
  "filter" : "(def l '(3 4 5 6 7))",
  "functions" : "(def n 0)",
  "seqs" : "(def n 0)",
  "uce" : "(defn uce [x]\r\n  (fn [m] ((fn e [x m]\r\n             (if (seq? x)\r\n               (apply ({'+ + '- - '* * '/ /} (first x))\r\n                      (map #(e % m) (rest x)))\r\n               (m x x)))\r\n           x m)))",
  "make_map" : "(defn make-map [keys vals]\r\n  (apply hash-map (interleave keys vals)))",
  "my_group_by" : "(defn my-group-by [f s]\r\n  (reduce\r\n   (fn [m x] (assoc m (f x) (conj (m (f x) []) x)))\r\n   {} s))",
  "fib" : "(defn fib [a b]\r\n  (lazy-seq (cons a (fib b (+ a b)))))",
  "shifter" : "(defn shifter [n s]\r\n  (take (count s) (drop (mod n (count s)) (cycle s))))",
  "nth_element" : "(defn nth-element [s n]\r\n  (last (take (inc n) s)))",
  "truth" : "(def truth (= false true))",
  "last" : "(defn my-last [s]\r\n  (if (next s)\r\n    (recur (next s))\r\n    (first s)))",
  "spaz_out" : "(defn spaz-out [f init]\r\n  (cons init\r\n        (lazy-seq\r\n         (spaz-out f (f init)))))",
  "mycomp" : "(defn mycomp [f & gs]\r\n  (if gs\r\n    #(f (apply (apply mycomp gs) (conj %& %)))\r\n    f))",
  "k" : "(defn k [i s]\r\n  (set\r\n   (if (= i 0)\r\n     [#{}]\r\n     (mapcat #(for [p (k (- i 1) %2)] (conj p %))\r\n             s (next (iterate next s))))))",
  "myreductions" : "(defn my-reductions\r\n  ([f [a & b]] (my-reductions f a b))\r\n  ([f a b]\r\n   (let [m (atom a)]\r\n     (cons a (map #(swap! m f %) b)))))",
  "conj_set" : "(def n 0)",
  "double" : "(def f \r\n  (fn [n]\r\n    ))",
  "sym_diff" : "(defn sym-diff [a b]\r\n  (into (set (remove b a)) (remove a b)))",
  "tri_path" : "(defn tri-path [s]\r\n  (first\r\n   (reduce\r\n    #(map + (map min (butlast %1) (rest %1)) %2)\r\n    (reverse s))))",
  "db" : "(defn digits [n b]\r\n  (if (< n b)\r\n    [n]\r\n    (conj (digits (quot n b) b) (rem n b))))",
  "sets" : "(def s #{:a :b :c})",
  "mypal" : "(defn mypal [s]\r\n  (= (seq s) (reverse (seq s))))",
  "cartesian" : "(defn cartesian [x y]\r\n  (set (for [a x b y] [a b])))",
  "perfect_square" : "(defn perfect-square [s]\r\n  (let [l (re-seq #\"\\d+\" s)]\r\n    (clojure.string/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} l))))",
  "inject" : "(defn inject [x coll]\r\n  (rest (interleave (repeat x) coll)))",
  "word_sort" : "(defn word-sort [s]\r\n  (sort-by #(.toLowerCase %) (re-seq #\"\\w+\" s)))",
  "reversi" : "(defn reversi [board p]\r\n  (let [o '{b w w b}\r\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\r\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\r\n        e (map key (filter #(= 'e (val %)) b))\r\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\r\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\r\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\r\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\r\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))",
  "lazy" : "(defn lazy [& s]\r\n  (loop [v (vec s)]\r\n    (let [first-vals (map first v)\r\n          smallest (apply min first-vals)]\r\n      (if (= smallest (apply max first-vals))\r\n        smallest\r\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\r\n          (recur (update-in v [i] next)))))))",
  "sh" : "(defn sh [n [x & r]]\r\n  (if x\r\n    (if (sequential? x)\r\n      (let [sub (sh n x)]\r\n        (cons sub (sh (- n (reduce + (flatten sub))) r)))\r\n      (if (<= x n)\r\n        (cons x (sh (- n x) r))\r\n        ()))))",
  "half_truth" : "(defn half-truth [& vs]\r\n  (true? (and (some not vs)\r\n              (some identity vs))))",
  "longest_subseq" : "(defn longest-subseq [s]\r\n  (or (first (for [l (reverse (range 2 (count s)))\r\n                   f (filter #(apply < %) (partition l 1 s))]\r\n               f)) []))",
  "quine" : "(defn quine []\r\n  (fn []\r\n    (let [x '(list 'fn []\r\n                   (list 'let ['x (list 'quote x)]\r\n                         (list 'str x)))]\r\n      (str (list 'fn []\r\n                 (list 'let ['x (list 'quote x)]\r\n                       (list 'str x)))))))",
  "eulerian" : "(defn eulerian [e]\r\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\r\n    (not (next (reduce\r\n                (fn [g e]\r\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\r\n                    (conj (disj g a b) (into a b))))\r\n                #{}\r\n                e)))\r\n    false))",
  "cards" : "(defn cards [c]\r\n  {:suit ({\\H :heart \\C :club \\S :spade \\D :diamond} (first c))\r\n   :rank ((zipmap \"23456789TJQKA\" (range)) (second c))})",
  "rn" : "(defn rn [n]\r\n  (->> (map {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} n)\r\n       (partition 2 1 [0])\r\n       (map (fn [[a b]] (if (< a b) (- a) a)))\r\n       (apply +)))",
  "count_elements" : "(defn count-elements [s]\r\n  (loop [x s acc 0]\r\n    (if (empty? x)\r\n      acc\r\n      (recur (rest x) (inc acc)))))",
  "happy" : "(defn happy [n]\r\n  (loop [n n\r\n         s #{}]\r\n    (let [x (apply + (map #(let [i (- (int %) (int \\0))] (* i i)) (str n)))]\r\n      (cond (= x 1) true\r\n            (s x) false\r\n            :else (recur x (conj s x))))))",
  "bal_num" : "(defn bal-num [n]\r\n  (let [s (map #(- (int %) 48) (str n))\r\n        l (/ (count s) 2)\r\n        [a b] (map #(apply + (take l %)) [s (into () s)])]\r\n    (= a b)))",
  "lev" : "(defn lev [s t]\r\n  (let [f (fn [f s t]\r\n            (cond\r\n              (empty? s) (count t)\r\n              (empty? t) (count s)\r\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\r\n                      (min (inc (f f (rest s) t))\r\n                           (inc (f f s (rest t)))\r\n                           (+ cost (f f (rest s) (rest t)))))))\r\n        g (memoize f)]\r\n    (g g s t)))",
  "black_box" : " (defn black-box [c]\r\n  ((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))",
  "myjuxt" : "(defn myjuxt [& f]\r\n  (fn [& a]\r\n    (map #(apply % a) f)))",
  "trans_closure" : "(defn trans-closure [r]\r\n  (loop [s r]\r\n    (let [n (into s\r\n                  (for [[a b] s [c d] s\r\n                        :when (= b c)]\r\n                    [a d]))]\r\n      (if (= n s) n (recur n)))))",
  "conway" : "(defn conway [board]\r\n  (let [r (range (count board))\r\n        v [-1 0 1]\r\n        a \\#]\r\n    (for [y r]\r\n      (apply str (for [x r c [(count\r\n                               (for [j v\r\n                                     k v\r\n                                     :when (= a (get-in board [(+ y j) (+ x k)]))]\r\n                                 1))]]\r\n                   (if (or (= c 3) (and (= c 4) (= a (get-in board [y x]))))\r\n                     a\r\n                     \\ ))))))",
  "veitch" : "(defn veitch [I]\r\n  (disj (into #{} (map (fn [s]\r\n                         ((reduce\r\n                           (fn [[d f u] x]\r\n                             (let [U (disj u x)\r\n                                   m (fn [t] (map #(conj % t) f))\r\n                                   P #(symbol (.toUpperCase (str %)))\r\n                                   L #(symbol (.toLowerCase (str %)))\r\n                                   F (into (m (L x)) (m (P x)))]\r\n                               (if (every? #(contains? I %) (map #(into (into d U) %) F))\r\n                                 [d F U]\r\n                                 [(conj d x) f U])))\r\n                           [#{} [#{}] s]\r\n                           s) 0)) I))\r\n        '#{A d}))",
  "ttt2" : "(defn ttt [p board]\r\n  (let [win? #(let [b (concat % (apply map list %)\r\n                              [(map nth % (range)) (map nth (map reverse %) (range))])]\r\n                (some #{[p p p]} b))]\r\n    (set\r\n     (for [y (range 3), x (range 3),\r\n           :when (and (= :e (get-in board [y x]))\r\n                      (win? (assoc-in board [y x] p)))]\r\n       [y x]))))"
}