{
  "find_path" : "(defn find-path [s e]\r\n  (loop [opts [s] depth 1]\r\n    (if (some #{e} opts)\r\n      depth\r\n      (letfn [(solutions [n]\r\n                (concat\r\n                 [(* n 2) (+ n 2)]\r\n                 (if (even? n) [(/ n 2)] [])))]\r\n        (recur (mapcat solutions opts) (inc depth))))))",
  "compress" : "(defn compress [s]\r\n  (map first\r\n       (partition-by identity s)))",
  "map" : "(def l '(6 7 8))", 
  "vectors" : "(def v [:a :b :c])",
  "ttt" : "(defn ttt [board]\r\n  (some {[:x :x :x] :x [:o :o :o] :o}\r\n        (concat board (apply map list board)\r\n                (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\r\n                  (for [[x y] d] ((board x) y))))))",
  "pf" : "(defn pf [s]\r\n  (if (every? coll? s)\r\n    (mapcat pf s)\r\n    [s]))",
  "get_highest" : "(defn get-highest [& all]\r\n  (last (sort all)))",
  "penultimate" : "(defn penultimate [s]\r\n  (second (reverse s)))",
  "dupseq" : "(defn dupseq [s]\r\n  (interleave s s))",
  "digits" : "(defn digits [x y]\r\n  (map #(- (int %) (int \\0)) (str (* x y))))",
  "primes" : "(defn primes [n]\r\n  (->>\r\n   (range)\r\n   (drop 2)\r\n   (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\r\n   (take n)))",
  "getcaps" : "(defn getcaps [s]\r\n  (apply str (re-seq #\"[A-Z]\" s)))",
  "roman" : "(defn roman [x]\r\n  (cond\r\n    (<= 1000 x) (str \"M\" (roman (- x 1000)))\r\n    (<= 900 x) (str \"CM\" (roman (- x 900)))\r\n    (<= 500 x) (str \"D\" (roman (- x 500)))\r\n    (<= 400 x) (str \"CD\" (roman (- x 400)))\r\n    (<= 100 x) (str \"C\" (roman (- x 100)))\r\n    (<= 90 x) (str \"XC\" (roman (- x 90)))\r\n    (<= 50 x) (str \"L\" (roman (- x 50)))\r\n    (<= 40 x) (str \"XL\" (roman (- x 40)))\r\n    (<= 10 x) (str \"X\" (roman (- x 10)))\r\n    (<= 9 x) (str \"IX\" (roman (- x 9)))\r\n    (<= 5 x) (str \"V\" (roman (- x 5)))\r\n    (<= 4 x) (str \"IV\" (roman (- x 4)))\r\n    (<= 1 x) (str \"I\" (roman (- x 1)))\r\n    true \"\"))",
  "totient" : "(defn totient [a]\r\n  (count\r\n   (for [b (range a)\r\n         :when (not-any? #(= 0 (rem a %) (rem b %)) (range 2 a))]\r\n     b)))",
  "lists" : "(def l (list :a :b :c))",
  "hello" : "(defn hello [name]\r\n  (str \"Hello, \" name \"!\"))",
  "symmetric" : "(defn symmetric? [t]\r\n  (= t ((fn m [[v l r]] (if v [v (m r) (m l)])) t)))",
  "lt" : "(defn lt [b]\r\n  (let [z (apply max 0\r\n                 (for [b [b (vec (reverse b))]\r\n                       y (range (count b))\r\n                       x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\r\n                       [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\r\n                       :let [s (loop [m m\r\n                                      d [i a]\r\n                                      [l h :as r] [x x]\r\n                                      s 0\r\n                                      [w & e :as b] (drop y b)]\r\n                                 (cond\r\n                                   (and w (>= l 0) (every? #(bit-test w %) (range l (inc h))))\r\n                                   (recur m d (map + d r) (+ s 1 (- h l)) e)\r\n                                   (< h l) s\r\n                                   (= 0 m) s\r\n                                   (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\r\n                       :when s]\r\n                   s))]\r\n    (when (> z 1) z)))",
  "maths" : "(def expr (= (- 10 (* 2 3)) 4))",
  "strings" : "(def s (. \"'hello'.toUpperCase\"))",
  "f" : "(defn f [grid]\r\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\r\n        parts (for [y (range (count grid))\r\n                    x (range (count (nth grid y)))\r\n                    :let [e (get-in grid [y x])]]\r\n                {({\\C :cat \\M :mouse \\# :wall \\space :space} e) [x y]})\r\n        game (apply merge-with conj {:wall [] :space []} parts)\r\n        spaces (conj (set (:space game)) (:mouse game))]\r\n    (loop [open [(:cat game)] visited #{}]\r\n      (cond\r\n        (empty? open) false\r\n        (= (first open) (:mouse game)) true\r\n        :else (let [visited (conj visited (first open))\r\n                    neigh (filter spaces (neighbors (first open)))\r\n                    neigh (remove visited neigh)\r\n                    open (concat (rest open) (remove visited neigh))]\r\n                (recur open visited))))))",
  "drop_every_nth" : "(defn drop-every-nth [s n]\r\n  (apply concat (partition-all (dec n) n s)))",
  "my_merge_with" : "(defn my-merge-with [f & ms]\r\n  (reduce (fn [am m]\r\n            (into am (for [[k v] m]\r\n                       (if (contains? am k)\r\n                         [k (f (am k) v)]\r\n                         [k v]))))\r\n          ms))",
  "deinterleave" : "(defn deinterleave [coll n]\r\n  (apply map list (partition n coll)))",
  "my_trampoline" : "(defn my-trampoline [f & x]\r\n  (if (fn? f)\r\n    (my-trampoline (apply f x))\r\n    f))",
  "pascal" : "(defn pascal [n]\r\n  (loop [x 1 l [1]]\r\n    (if (= x n) l\r\n        (recur (inc x) (vec (map + (cons 0 l) (conj l 0)))))))",
  "cw" : "(defn cw [word board]\r\n  (let [across (map #(clojure.string/escape % {\\space \"\", \\_ \\.}) board)\r\n        down (apply map str across)]   ;; transpose the board so down becomes across\r\n    (string? (->> (concat across down)\r\n                  (mapcat #(clojure.string/split % #\"#\"))\r\n                  (some #(re-matches (re-pattern %) word))))))",
  "pack" : "(defn pack [s]\r\n  (partition-by identity s))",
  "powerset" : "(defn powerset [s]\r\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))",
  "lcm" : "(defn lcm [& args]\r\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (/ (reduce * args) (reduce gcd args))))",
  "anagram" : "(defn anagram [c]\r\n  (set (for [[_ g] (group-by frequencies c)\r\n             :when (next g)]\r\n         (set g))))",
  "ss" : "(defn ss [coll]\r\n  (let [digits (fn digits [n]\r\n                 (if (< n 10)\r\n                   (list n)\r\n                   (cons (rem n 10) (digits (quot n 10)))))]\r\n    (count (filter\r\n            #(< % (apply + (map * (digits %) (digits %))))\r\n            coll))))",
  "graph" : "(defn graph [g]\r\n  ((fn f [e]\r\n     (#(if (= e %) (= % g) (f %))\r\n      (reduce (fn [a b] (into a (filter #(some (set b) %) g)))\r\n              #{}\r\n              e)))\r\n   #{(first g)}))",
  "set_sect" : "(defn set-sect [a b]\r\n  (set (filter a b)))",
  "flipper" : "(defn flipper [f]\r\n  #(f %2 %))",
  "word_chain" : "(defn word-chain [s]\r\n  (or (some (fn [w]\r\n              ((fn f [a s]\r\n                 (or (empty? s)\r\n                     (some #(if (loop [[a & b :as c] (seq a) [d & e :as g] (seq %)]\r\n                                  (if (= a d)\r\n                                    (recur b e)\r\n                                    (or (= b e) (= b g) (= c e))))\r\n                              (f % (disj s %)))\r\n                           s)))\r\n               w (disj s w)))\r\n            s)\r\n      false))",
  "ps" : "(defn ps [n]\r\n  (first (for [o (range 1 (- n 2))\r\n               [a b c] [(for [x [(- n o) (+ n o) n]]\r\n                          (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\r\n               :when (or a b)]\r\n           (and a b c))))",
  "maps" : "(def n 20)",
  "seq_prons" : "(defn seq-prons [s]\r\n  (next (iterate #(mapcat (juxt count first)\r\n                          (partition-by identity %)) s)))",
  "hack" : "(defn hack [n s]\r\n  [(take n s) (drop n s)])",
  "reverse_seq" : "(defn reverse-seq [s]\r\n  (reduce conj () s))",
  "makeflat" : "(defn makeflat [s]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq s))))",
  "rest" : "(def v [20 30 40])",
  "perfect_nums" : "(defn perfect-nums [x]\r\n  (= x (apply + (filter #(= 0 (mod x %)) (range 1 x)))))",
  "closure" : "(defn closure [n] #(apply * (repeat n %)))",
  "intervals" : "(defn intervals [coll]\r\n  (reverse (reduce (fn [[[a b] & r :as is] n]\r\n                     (if (and a (= (inc b) n))\r\n                       (cons [a n] r)\r\n                       (cons [n n] is)))\r\n                   ()\r\n                   (distinct (sort coll)))))",
  "gtw" : "(defn gtw [n p [x & r]]\r\n  (lazy-seq\r\n   (when x\r\n     (let [remaining (if (p x) (dec n) n)]\r\n       (when (pos? remaining)\r\n         (cons x (gtw remaining p r)))))))",
  "conj_list" : "(def l '(1 2 3 4))",
  "camel" : "(defn camel [s]\r\n  (let [words (re-seq #\"[a-zA-Z]+\" s)\r\n        words (cons (first words)\r\n                    (map clojure.string/capitalize\r\n                         (rest words)))]\r\n    (apply str words)))",
  "splatter" : "(defn splatter [s n]\r\n  (mapcat\r\n   (fn [s]\r\n     (repeat n s)) s))",
  "split_by_type" : "(defn split-by-type [s]\r\n  (vals (group-by type s)))",
  "gcd" : "(defn gcd [a b]\r\n  (if (= 0 b) a (recur b (mod a b))))",
  "conj_map" : "(def kv [:b 2])",
  "tree" : "(defn tree? [n]\r\n  (or (nil? n)\r\n      (and (coll? n)\r\n           (= 3 (count n))\r\n           (every? tree? (rest n)))))",
  "key_val" : "(defn key-val [c]\r\n  (loop [[f & r] c, kvm {}]\r\n    (if (nil? f)\r\n      kvm\r\n      (let [[vs l] (split-with (complement keyword?) r)]\r\n        (recur l (assoc kvm f vs))))))",
  "mymap" : "(defn mymap [f l]\r\n  (rest (reductions #(f %2) 0 l)))",
  "classes" : "(defn classes [f c]\r\n  (set (map set (vals (group-by f c)))))",
  "bin" : "(defn bin [n]\r\n  (apply + (map #(if (= \\1 %1)\r\n                   (apply * (repeat %2 2)) 0)\r\n                (reverse n) (range))))",
  "myrange" : "(defn myrange [start end]\r\n  (loop [n start res []]\r\n   (if (>= n end) res (recur (inc n) (conj res n)))))",
  "conj_vector" : "(def v [1 2 3 4])",
  "my_interleave" : "(defn my-interleave [a b]\r\n  (mapcat list a b))",
  "factorial" : "(defn factorial [n]\r\n  (reduce * (range 1 (inc n))))",
  "filter" : "(def l '(3 4 5 6 7))",
  "functions" : "(def n 0)",
  "seqs" : "(def n 3)",
  "uce" : "(defn uce [x]\r\n  (fn [m] ((fn e [x m]\r\n             (if (seq? x)\r\n               (apply ({'+ + '- - '* * '/ /} (first x))\r\n                      (map #(e % m) (rest x)))\r\n               (m x x)))\r\n           x m)))",
  "make_map" : "(defn make-map [keys vals]\r\n  (apply hash-map (interleave keys vals)))",
  "my_group_by" : "(defn my-group-by [f s]\r\n  (reduce\r\n   (fn [m x] (assoc m (f x) (conj (m (f x) []) x)))\r\n   {} s))",
  "fib" : "(defn fib [a b]\r\n  (lazy-seq (cons a (fib b (+ a b)))))",
  "shifter" : "(defn shifter [n s]\r\n  (take (count s) (drop (mod n (count s)) (cycle s))))",
  "nth_element" : "(defn nth-element [s n]\r\n  (last (take (inc n) s)))",
  "truth" : "(def truth (= true true))",
  "last" : "(defn my-last [s]\r\n  (if (next s)\r\n    (my-last (next s))\r\n    (first s)))",
  "spaz_out" : "(defn spaz-out [f init]\r\n  (cons init\r\n        (lazy-seq\r\n         (spaz-out f (f init)))))",
  "mycomp" : "(defn mycomp [f & gs]\r\n  (if gs\r\n    #(f (apply (apply mycomp gs) (conj %& %)))\r\n    f))",
  "k" : "(defn k [i s]\r\n  (set\r\n   (if (= i 0)\r\n     [#{}]\r\n     (mapcat #(for [p (k (- i 1) %2)] (conj p %))\r\n             s (next (iterate next s))))))",
  "myreductions" : "(defn my-reductions\r\n  ([f [a & b]] (my-reductions f a b))\r\n  ([f a b]\r\n   (let [m (atom a)]\r\n     (cons a (map #(swap! m f %) b)))))",
  "conj_set" : "(def n 0)",
  "double" : "(def f \r\n  (fn [n]\r\n    (* n 2)))",
  "sym_diff" : "(defn sym-diff [a b]\r\n  (into (set (remove b a)) (remove a b)))",
  "tri_path" : "(defn tri-path [s]\r\n  (first\r\n   (reduce\r\n    #(map + (map min (butlast %1) (rest %1)) %2)\r\n    (reverse s))))",
  "db" : "(defn digits [n b]\r\n  (if (< n b)\r\n    [n]\r\n    (conj (digits (quot n b) b) (rem n b))))",
  "sets" : "(def s #{:a :b :c})",
  "mypal" : "(defn mypal [s]\r\n  (= (seq s) (reverse (seq s))))",
  "cartesian" : "(defn cartesian [x y]\r\n  (set (for [a x b y] [a b])))",
  "perfect_square" : "(defn perfect-square [s]\r\n  (let [l (re-seq #\"\\d+\" s)]\r\n    (clojure.string/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} l))))",
  "inject" : "(defn inject [x coll]\r\n  (rest (interleave (repeat x) coll)))",
  "word_sort" : "(defn word-sort [s]\r\n  (sort-by #(.toLowerCase %) (re-seq #\"\\w+\" s)))",
  "reversi" : "(defn reversi [board p]\r\n  (let [o '{b w w b}\r\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\r\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\r\n        e (map key (filter #(= 'e (val %)) b))\r\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\r\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\r\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\r\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\r\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))",
  "lazy" : "(defn lazy [& s]\r\n  (loop [v (vec s)]\r\n    (let [first-vals (map first v)\r\n          smallest (apply min first-vals)]\r\n      (if (= smallest (apply max first-vals))\r\n        smallest\r\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\r\n          (recur (update-in v [i] next)))))))",
  "sh" : "(defn sh [n [x & r]]\r\n  (if x\r\n    (if (sequential? x)\r\n      (let [sub (sh n x)]\r\n        (cons sub (sh (- n (reduce + (flatten sub))) r)))\r\n      (if (<= x n)\r\n        (cons x (sh (- n x) r))\r\n        ()))))",
  "half_truth" : "(defn half-truth [& vs]\r\n  (true? (and (some not vs)\r\n              (some identity vs))))",
  "longest_subseq" : "(defn longest-subseq [s]\r\n  (or (first (for [l (reverse (range 2 (count s)))\r\n                   f (filter #(apply < %) (partition l 1 s))]\r\n               f)) []))",
  "quine" : "(defn quine []\r\n  (fn []\r\n    (let [x '(list 'fn []\r\n                   (list 'let ['x (list 'quote x)]\r\n                         (list 'str x)))]\r\n      (str (list 'fn []\r\n                 (list 'let ['x (list 'quote x)]\r\n                       (list 'str x)))))))",
  "eulerian" : "(defn eulerian [e]\r\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\r\n    (not (next (reduce\r\n                (fn [g e]\r\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\r\n                    (conj (disj g a b) (into a b))))\r\n                #{}\r\n                e)))\r\n    false))",
  "cards" : "(defn cards [c]\r\n  {:suit ({\\H :heart \\C :club \\S :spade \\D :diamond} (first c))\r\n   :rank ((zipmap \"23456789TJQKA\" (range)) (second c))})",
  "rn" : "(defn rn [n]\r\n  (->> (map {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} n)\r\n       (partition 2 1 [0])\r\n       (map (fn [[a b]] (if (< a b) (- a) a)))\r\n       (apply +)))",
  "count_elements" : "(defn count-elements [s]\r\n  (loop [x s acc 0]\r\n    (if (empty? x)\r\n      acc\r\n      (recur (rest x) (inc acc)))))",
  "happy" : "(defn happy [n]\r\n  (loop [n n\r\n         s #{}]\r\n    (let [x (apply + (map #(let [i (- (int %) (int \\0))] (* i i)) (str n)))]\r\n      (cond (= x 1) true\r\n            (s x) false\r\n            :else (recur x (conj s x))))))",
  "bal_num" : "(defn bal-num [n]\r\n  (let [s (map #(- (int %) 48) (str n))\r\n        l (/ (count s) 2)\r\n        [a b] (map #(apply + (take l %)) [s (into () s)])]\r\n    (= a b)))",
  "lev" : "(defn lev [s t]\r\n  (let [f (fn [f s t]\r\n            (cond\r\n              (empty? s) (count t)\r\n              (empty? t) (count s)\r\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\r\n                      (min (inc (f f (rest s) t))\r\n                           (inc (f f s (rest t)))\r\n                           (+ cost (f f (rest s) (rest t)))))))\r\n        g (memoize f)]\r\n    (g g s t)))",
  "black_box" : " (defn black-box [c]\r\n  ((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))",
  "myjuxt" : "(defn myjuxt [& f]\r\n  (fn [& a]\r\n    (map #(apply % a) f)))",
  "trans_closure" : "(defn trans-closure [r]\r\n  (loop [s r]\r\n    (let [n (into s\r\n                  (for [[a b] s [c d] s\r\n                        :when (= b c)]\r\n                    [a d]))]\r\n      (if (= n s) n (recur n)))))",
  "conway" : "(defn conway [board]\r\n  (let [r (range (count board))\r\n        v [-1 0 1]\r\n        a \\#]\r\n    (for [y r]\r\n      (apply str (for [x r c [(count\r\n                               (for [j v\r\n                                     k v\r\n                                     :when (= a (get-in board [(+ y j) (+ x k)]))]\r\n                                 1))]]\r\n                   (if (or (= c 3) (and (= c 4) (= a (get-in board [y x]))))\r\n                     a\r\n                     \\ ))))))",
  "veitch" : "(defn veitch [I]\r\n  (disj (into #{} (map (fn [s]\r\n                         ((reduce\r\n                           (fn [[d f u] x]\r\n                             (let [U (disj u x)\r\n                                   m (fn [t] (map #(conj % t) f))\r\n                                   P #(symbol (.toUpperCase (str %)))\r\n                                   L #(symbol (.toLowerCase (str %)))\r\n                                   F (into (m (L x)) (m (P x)))]\r\n                               (if (every? #(contains? I %) (map #(into (into d U) %) F))\r\n                                 [d F U]\r\n                                 [(conj d x) f U])))\r\n                           [#{} [#{}] s]\r\n                           s) 0)) I))\r\n        '#{A d}))",
  "ttt2" : "(defn ttt [p board]\r\n  (let [win? #(let [b (concat % (apply map list %)\r\n                              [(map nth % (range)) (map nth (map reverse %) (range))])]\r\n                (some #{[p p p]} b))]\r\n    (set\r\n     (for [y (range 3), x (range 3),\r\n           :when (and (= :e (get-in board [y x]))\r\n                      (win? (assoc-in board [y x] p)))]\r\n       [y x]))))",
  "diamond" : "(ns diamond)\r\n\r\n(defn diamond [])\r\n",
  "isogram" : "(ns isogram)\r\n\r\n(defn isogram? [])\r\n",
  "gigasecond" : "(ns gigasecond)\r\n\r\n(defn from []  \r\n    \r\n)\r\n",
  "leap" : "(ns leap)\r\n\r\n(defn leap-year? [year] ;; <- argslist goes here\r\n  \r\n)\r\n",
  "zipper" : "(ns zipper)\r\n\r\n(defn from-tree [] )\r\n\r\n(defn value [] )\r\n\r\n(defn left [])\r\n\r\n(defn right [])\r\n\r\n(defn to-tree [])\r\n\r\n(defn up [])\r\n\r\n(defn set-value [])\r\n\r\n(defn set-left [])\r\n\r\n(defn set-right [])\r\n",
  "roman_numerals" : "(ns roman-numerals)\r\n\r\n(defn numerals [] \r\n      \r\n)\r\n",
  "minesweeper" : "(ns minesweeper)\r\n\r\n(defn draw [])\r\n",
  "pov" : "(ns pov)\r\n\r\n(defn of [] \r\n      \r\n)\r\n\r\n(defn path-from-to [])\r\n",
  "matching_brackets" : "(ns matching-brackets)\r\n\r\n(defn valid? [])\r\n",
  "dominoes" : "(ns dominoes)\r\n\r\n(defn can-chain? [])\r\n",
  "rotational_cipher" : "(ns rotational-cipher)\r\n\r\n(defn rotate [] \r\n      \r\n)\r\n",
  "kindergarten_garden" : "(ns kindergarten-garden)\r\n\r\n(defn garden [])\r\n",
  "all_your_base" : "(ns all-your-base)\r\n\r\n(defn convert [])\r\n",
  "spiral_matrix" : "(ns spiral-matrix)\r\n\r\n(defn spiral [n])\r\n",
  "anagram2" : "(ns anagram)\r\n\r\n(defn anagrams-for [word prospect-list])\r\n",
  "atbash_cipher" : "(ns atbash-cipher)\r\n\r\n(defn encode [])\r\n",
  "grade_school" : "(ns grade-school)\r\n\r\n(defn grade [school grade]  \r\n    \r\n)\r\n\r\n(defn add [school name grade]  \r\n    \r\n)\r\n\r\n(defn sorted [school]  \r\n    \r\n)\r\n",
  "meetup" : "(ns meetup)\r\n\r\n(defn meetup [] \r\n  )",
  "two_fer" : "(ns two-fer)\r\n\r\n(defn two-fer [name])\r\n",
  "run_length_encoding" : "(ns run-length-encoding)\r\n\r\n(defn run-length-encode\r\n  \"encodes a string with run-length-encoding\"\r\n  [plain-text])\r\n\r\n(defn run-length-decode\r\n  \"decodes a run-length-encoded string\"\r\n  [cipher-text])\r\n",
  "wordy" : "(ns wordy)\r\n\r\n(defn evaluate [] \r\n      \r\n)\r\n",
  "sieve" : "(ns sieve)\r\n\r\n(defn sieve [] \r\n      \r\n)\r\n",
  "binary" : "(ns binary)\r\n\r\n(defn to-decimal [])\r\n",
  "pig_latin" : "(ns pig-latin)\r\n\r\n(defn translate [] \r\n      \r\n)\r\n",
  "bob" : "(ns bob)\r\n\r\n(defn response-for [s])\r\n",
  "rna_transcription" : "(ns rna-transcription)\r\n\r\n(defn to-rna [dna])\r\n",
  "pascals_triangle" : "(ns pascals-triangle)\r\n\r\n(def triangle)\r\n\r\n(defn row [])\r\n",
  "space_age" : "(ns space-age)\r\n\r\n(defn on-mercury [])\r\n\r\n(defn on-venus [])\r\n\r\n(defn on-earth [] \r\n      \r\n)\r\n\r\n(defn on-mars [])\r\n\r\n(defn on-jupiter [])\r\n\r\n(defn on-saturn [])\r\n\r\n(defn on-uranus [])\r\n\r\n(defn on-neptune [])\r\n",
  "queen_attack" : "(ns queen-attack)\r\n\r\n(defn board-string [] ;; <- glister goes here\r\n      \r\n)\r\n\r\n(defn can-attack [])\r\n",
  "acronym" : "(ns acronym)\r\n\r\n(defn acronym\r\n  \"Converts phrase to its acronym.\"\r\n  [phrase])\r\n",
  "secret_handshake" : "(ns secret-handshake)\r\n\r\n(defn commands [] \r\n      \r\n)\r\n",
  "crypto_square" : "(ns crypto-square)\r\n\r\n(defn normalize-plaintext [])\r\n\r\n(defn square-size [])\r\n\r\n(defn plaintext-segments [])\r\n\r\n(defn ciphertext [])\r\n\r\n(defn normalize-ciphertext [])\r\n",
  "word_count" : "(ns word-count)\r\n\r\n(defn word-count [s])\r\n",
  "armstrong_numbers" : "(ns armstrong-numbers)\r\n\r\n(defn armstrong? [num])\r\n",
  "hamming" : "(ns hamming)\r\n\r\n(defn distance [strand1 strand2])\r\n",
  "scrabble_score" : "(ns scrabble-score)\r\n\r\n(defn score-letter [] \r\n      \r\n)\r\n\r\n(defn score-word [])\r\n",
  "octal" : "(ns octal)\r\n\r\n(defn to-decimal [])\r\n",
  "raindrops" : "(ns raindrops)\r\n\r\n(defn convert [] \r\n      \r\n)\r\n",
  "binary_search_tree" : "(ns binary-search-tree)\r\n\r\n(defn value [])\r\n\r\n(defn singleton [])\r\n\r\n(defn insert [])\r\n\r\n(defn left [])\r\n\r\n(defn right [])\r\n\r\n(defn to-list [])\r\n\r\n(defn from-list [])\r\n",
  "nth_prime" : "(ns nth-prime)\r\n\r\n(defn nth-prime \r\n  \"Returns the prime number in the nth position.\"\r\n  [n] \r\n  )\r\n",
  "largest_series_product" : "(ns largest-series-product)\r\n\r\n(defn largest-product [] \r\n      \r\n)\r\n",
  "protein_translation" : "(ns protein-translation)\r\n\r\n(defn translate-codon [] \r\n      \r\n)\r\n\r\n(defn translate-rna [])\r\n",
  "sublist" : "(ns sublist)\r\n\r\n(defn classify [list1 list2] \r\n      \r\n)\r\n",
  "prime_factors" : "(ns prime-factors)\r\n\r\n(defn of [] \r\n      \r\n)\r\n",
  "triangle" : "(ns triangle)\r\n\r\n(defn is-valid? [])\r\n\r\n(defn equilateral? [])\r\n\r\n(defn isosceles? [])\r\n\r\n(defn scalene? [])\r\n",
  "reverse_string" : "(ns reverse-string)\r\n\r\n(defn reverse-string [s] (apply str (reverse s)))\r\n",
  "beer_song" : "(ns beer-song)\r\n\r\n(defn verse\r\n  \"Returns the nth verse of the song.\"\r\n  [num])\r\n\r\n(defn sing\r\n  \"Given a start and an optional end, returns all verses in this interval. If\r\n  end is not given, the whole song from start is sung.\"\r\n  ([start])\r\n  ([start end]))\r\n",
  "binary_search" : "(ns binary-search)\r\n\r\n(defn search-for [])\r\n\r\n(defn middle [])\r\n",
  "clock" : "(ns clock)\r\n\r\n(defn clock->string [clock])\r\n\r\n(defn clock [hours minutes])\r\n\r\n(defn add-time [clock time])\r\n",
  "allergies" : "(ns allergies)\r\n\r\n(defn allergies [])\r\n\r\n(defn allergic-to? [])\r\n",
  "say" : "(ns say)\r\n\r\n(defn number [num])\r\n",
  "luhn" : "(ns luhn)\r\n\r\n(defn valid? [])\r\n",
  "difference_of_squares" : "(ns difference-of-squares)\r\n\r\n(defn difference [])\r\n\r\n(defn sum-of-squares [])\r\n\r\n(defn square-of-sum [])\r\n",
  "complex_numbers" : "(ns complex-numbers)\r\n\r\n(defn real [[a b]])\r\n\r\n(defn imaginary [[a b]])\r\n\r\n(defn abs [[a b]])\r\n\r\n(defn conjugate [[a b]])\r\n\r\n(defn add [[a b] [c d]])\r\n\r\n(defn sub [[a b] [c d]])\r\n\r\n(defn mul [[a b] [c d]])\r\n\r\n(defn div [[a b] [c d]])\r\n",
  "poker" : "(ns poker)\r\n\r\n(defn best-hands [hands])\r\n",
  "go_counting" : "(ns go-counting)\r\n\r\n(defn territory [grid [x y]])\r\n\r\n(defn territories [grid])\r\n",
  "accumulate" : "(ns accumulate)\r\n\r\n(defn accumulate [] \r\n      \r\n)\r\n",
  "hexadecimal" : "(ns hexadecimal)\r\n\r\n(defn hex-to-int [])\r\n",
  "series" : "(ns series)\r\n\r\n(defn slices [string length])\r\n",
  "yacht" : "(ns yacht)\r\n\r\n(defn score [])\r\n",
  "grains" : "(ns grains)\r\n\r\n(defn square [] \r\n    \r\n)\r\n\r\n(defn total []  \r\n    \r\n)\r\n",
  "robot_simulator" : "(ns robot-simulator)\r\n\r\n(defn robot [] \r\n      \r\n)\r\n\r\n(defn simulate [])\r\n\r\n(defn turn-right [])\r\n\r\n(defn turn-left [])\r\n",
  "proverb" : "(ns proverb)\r\n\r\n(defn recite [] \r\n    \r\n)\r\n",
  "flatten_array" : "(ns flatten-array)\r\n\r\n(defn flatten [arr])\r\n",
  "pangram" : "(ns pangram)\r\n\r\n(defn pangram? [])\r\n",
  "bank_account" : "(ns bank-account)\r\n\r\n(defn open-account [] \r\n  )\r\n\r\n(defn close-account [] \r\n  )\r\n\r\n(defn get-balance [] \r\n  )\r\n\r\n(defn update-balance [] \r\n  )\r\n",
  "strain" : "(ns strain)\r\n\r\n(defn retain [] \r\n      \r\n)\r\n\r\n(defn discard [])\r\n",
  "sum_of_multiples" : "(ns sum-of-multiples)\r\n\r\n(defn sum-of-multiples [] \r\n      \r\n)\r\n",
  "collatz_conjecture" : "(ns collatz-conjecture)\r\n\r\n(defn collatz [num])\r\n",
  "trinary" : "(ns trinary)\r\n\r\n(defn to-decimal [] \r\n      \r\n)\r\n",
  "etl" : "(ns etl)\r\n\r\n(defn transform [source])\r\n",
  "perfect_numbers" : "(ns perfect-numbers)\r\n\r\n(defn classify [] \r\n      \r\n)\r\n",
  "hello_world" : "(ns hello-world)\r\n\r\n(defn hello []\r\n  \"Hello, World!\")\r\n",
  "nucleotide_count" : "(ns nucleotide-count)\r\n\r\n(defn count-of-nucleotide-in-strand [nucleotide strand])\r\n\r\n\r\n(defn nucleotide-counts [strand])\r\n",
  "phone_number" : "(ns phone-number)\r\n\r\n(defn number [num-string] \r\n      \r\n)\r\n\r\n(defn area-code [num-string])\r\n\r\n(defn pretty-print [num-string])\r\n",
  "change" : "(ns change)\r\n\r\n(defn issue [])\r\n",
  "isbn_verifier" : "(ns isbn-verifier)\r\n\r\n(defn isbn? [isbn])\r\n",
  "robot_name" : "(ns robot-name)\r\n\r\n(defn robot [])\r\n\r\n(defn robot-name [robot] \r\n      \r\n)\r\n\r\n(defn reset-name [robot])\r\n"
}